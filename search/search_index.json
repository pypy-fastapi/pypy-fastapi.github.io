{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Fastapi","text":""},{"location":"#welcome-to-fastapi","title":"Welcome to Fastapi","text":"<p>FastAPI is a modern, fast (high-performance) web framework for building APIs with Python <code>3.6+</code> based on standard Python type hints.(1)</p> <ol> <li> <ul> <li>Sebasti\u00e1n Ram\u00edrez, creator of FastAPI</li> </ul> </li> </ol> A FastAPI Application <ul> <li>The FastAPI framework: <code>pip install fastapi</code></li> <li>The Uvicorn web server: <code>pip install uvicorn</code></li> <li>The HTTPie text web client: <code>pip install httpie</code></li> <li>The Requests synchronous web client package: <code>pip install requests</code></li> <li>The HTTPX synchronous/asynchronous web client package: <code>pip install httpx</code></li> </ul> <p>Although curl is the best known text web client, I think HTTPie is easier to use. Also, it defaults to JSON encoding and decoding, which is a better match for FastAPI.</p> <p>FastAPI is heavily based on Python type hints. So, before diving into the framework, it is useful to review the basic concepts of type hinting, what they are, how they are implemented, and what their purpose is. This foundational knowledge will help you create robust, maintainable, and scalable APIs with FastAPI. (1)</p> <ol> <li> <p>Full Stack FastAPI, React, and MongoDB, Second edition by Marko Aleksendri\u0107, Ph.D.</p> <p>By the end of this chapter, you will have a deep understanding of the role of type annotations in Python with FastAPI and Pydantic. Pydantic is a modern Python library that enforces type hints at runtime, provides customizable and user-friendly errors when data is invalid, and allows definition of data structures using Python type annotations.</p> <p>You will be able to model your data with precision, leveraging the advanced features of Pydantic to make you a better and more productive FastAPI developer.</p> </li> </ol> Identify the Core 20% of FastAPI <p>FastAPI is a Python framework for building APIs quickly with high performance. The critical 20% of FastAPI to learn includes:</p> <ul> <li>Routing and Endpoints: Understand how to define routes using <code>@app.get()</code>, <code>@app.post()</code>, etc.</li> <li>Request and Response Handling: Learn to handle query parameters, path parameters, and JSON request bodies, and return responses with proper status codes.</li> <li>Pydantic Models: Master Pydantic for data validation and serialization.</li> <li>Dependency Injection: Use FastAPI\u2019s dependency system for reusable logic (e.g., authentication, database connections).</li> <li>Async/Await: Grasp asynchronous programming to leverage FastAPI\u2019s performance (e.g., <code>async def</code> for endpoints).</li> </ul> <p>Normal Python execution is synchronous: one thing at a time, in the order specified by the code. Sometimes we want to be asynchronous: do a little of one thing, then a little of another thing, back to the first thing, and so on. If all our code uses the CPU to calculate things (CPU bound), there\u2019s really no spare time to be asynchronous. But if we perform something that makes the CPU wait for an external thing to complete (I/O bound), we can be asynchronous.</p> <p>Asynchronous systems provide an event loop: requests for slow operations are sent and noted, but we don\u2019t hold up the CPU waiting for their responses. Instead, some immediate processing is done on each pass through the loop, and any responses that came in during that time are handled in the next pass.(1)</p> <ol> <li>FastAPI - Modern Python Web Development by Bill Lubanovic, pg-8</li> </ol>"},{"location":"#status-code","title":"Status Code","text":"<p>By default, FastAPI returns a <code>200</code> status code; exceptions raise <code>4xx</code> codes.</p>"},{"location":"#automated-documentation","title":"Automated Documentation","text":"<p>Convince your browser to visit the URL <code>http://localhost:8000/docs</code>.</p> <p>Where did that come from?</p> <p>FastAPI generates an OpenAPI specification from your code, and includes this page to display and test all your endpoints. This is just one ingredient of its secret sauce.</p>"},{"location":"#making-a-website","title":"Making a Website","text":"<p>The full service will have three layers, as I\u2019ve discussed earlier:</p> <ul> <li>Web : The web interface</li> <li>Service : The business logic</li> <li>Data : The precious DNA of the whole thing</li> </ul> <p>Plus the web service will have these cross-layer components:</p> <ul> <li>Model : Pydantic data definitions</li> <li>Tests : Unit, integration, and end-to-end tests</li> </ul> Interlude: Top-Down, Bottom-Up, Middle-Out? <p>When designing a website, you could start from one of the following:</p> <ul> <li>The Web layer and work down</li> <li>The Data layer and work up</li> <li>The Service layer and work out in both directions</li> </ul> <p>Do you already have a database, installed and loaded with data, and are just pining for a way to share it with the world? If so, you may want to tackle the Data layer\u2019s code and tests first, then the Service layer, and write the Web layer last.</p> <p>If you\u2019re following domain-driven design, you might start in the middle Service layer, defining your core entities and data models. Or you may want to evolve the web interface first, and fake calls to the lower layers until you know what you\u2019ll expect of them.</p>"},{"location":"#server","title":"SERVER","text":"<p>For FastAPI to run, it needs a server. In this case, a server is a software designed to serve web applications (or REST APIs). FastAPI relies on the asynchronous server gateway interface (ASGI), which enables async non-blocking applications, which is something you can completely use with your FastAPI capabilities.</p> <p>At present, the FastAPI documentation lists three compatible Python ASGI-compatible servers: Uvicorn, Hypercorn, and Daphne. This book will focus on Uvicorn, the most widely used and recommended option for working with FastAPI. Uvicorn offers high performance, and if you get stuck, there\u2019s extensive documentation available online.</p> <pre><code>pip install fastapi uvicorn\n</code></pre> <ul> <li>Full Stack FastAPI, React, and MongoDB, Second edition by Marko Aleksendri\u0107, pg: 73</li> </ul>"},{"location":"#farm-stack-fastapi-react-and-mongodb","title":"FARM Stack - FastAPI, React, and MongoDB","text":""},{"location":"#books","title":"Books","text":""},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2024/05/13/understanding-python-annotations-and-type-hints/","title":"Understanding Python Annotations and Type Hints","text":""},{"location":"blog/2024/05/13/understanding-python-annotations-and-type-hints/#understanding-python-annotations-and-type-hints","title":"Understanding Python Annotations and Type Hints","text":"<p>Python has introduced a powerful feature that helps developers write clearer, more maintainable code: type annotations, also known as type hints. But are annotations and type hints the same thing? In this post, we'll explore what they are, how they relate, and how you can document your Python projects using MkDocs.</p>"},{"location":"blog/2024/05/13/understanding-python-annotations-and-type-hints/#what-are-python-annotations-and-type-hints","title":"What Are Python Annotations and Type Hints?","text":"<p>In Python, annotations refer to the syntax that allows you to attach metadata to function parameters and return values. When these annotations specify types, they are called type hints. Essentially, annotations and type hints are the same feature, used interchangeably to indicate the expected data types in your code.</p> <p>For example:</p> <pre><code>def greet(name: str) -&gt; str:\n    return \"Hello \" + name\n</code></pre> <p>Here, <code>name: str</code> and <code>-&gt; str</code> are type annotations or type hints, signaling that <code>name</code> should be a string and the function returns a string.</p>"},{"location":"blog/2024/05/13/understanding-python-annotations-and-type-hints/#why-use-type-hints","title":"Why Use Type Hints?","text":"<ul> <li>Improved readability: They make your code easier to understand by explicitly stating what types are expected.</li> <li>Better tooling: Editors and IDEs can use type hints to provide better autocompletion and error detection.</li> <li>Static analysis: Tools like mypy can check your code for type consistency before runtime.</li> <li>Documentation: Type hints serve as a form of documentation embedded directly in your code.</li> </ul> <p>Note that Python itself does not enforce these types at runtime; they are mainly for humans and tools.</p>"},{"location":"blog/2024/05/13/understanding-python-annotations-and-type-hints/#summary","title":"Summary:","text":"<ul> <li>Type hints provide metadata about expected types in your code.</li> <li>Static type checkers use these hints to find type errors before execution.</li> <li>This helps you identify bugs early and improves code maintainability.</li> <li>Python does not enforce types at runtime; type hints are optional and for tooling support only.</li> </ul> <p>This proactive error detection is one of the primary benefits of adopting type hints in Python development</p>"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/","title":"Python Type Hints vs TypeScript: Understanding the Differences and Similarities","text":""},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#python-type-hints-vs-typescript-understanding-the-differences-and-similarities","title":"Python Type Hints vs TypeScript: Understanding the Differences and Similarities","text":"<p>Type hints in Python and TypeScript\u2019s static typing share a common goal: helping developers catch errors before running the code. However, they differ significantly in how they work and what guarantees they provide.</p> <p>This blog explores these differences and explains why Python\u2019s type hints are not quite the same as TypeScript\u2019s type system, even though they serve related purposes.</p>"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#what-are-type-hints-in-python","title":"What Are Type Hints in Python?","text":"<p>Python introduced type hints (or type annotations) starting with version 3.5 to allow developers to optionally specify expected types for variables, function parameters, and return values. For example:</p> <pre><code>def greet(name: str) -&gt; str:\n    return \"Hello \" + name\n</code></pre> <p>These annotations improve code readability and enable static analysis tools like <code>mypy</code> to check for type inconsistencies before runtime.</p> <p>Key points about Python type hints:</p> <ul> <li>They are optional and do not affect runtime behavior.</li> <li>Python itself does not enforce these types when the code runs.</li> <li>Static type checkers must be run separately to detect type errors.</li> <li>Type hints help IDEs provide better autocompletion and error detection.</li> <li>They serve as documentation and tooling aids rather than strict contracts.</li> </ul>"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#what-is-typescripts-type-system","title":"What Is TypeScript\u2019s Type System?","text":"<p>TypeScript is a statically typed superset of JavaScript that compiles to plain JavaScript. Its type system is integrated into the language and build process, meaning:</p> <ul> <li>Type checking happens at compile time.</li> <li>Code with type errors will not compile unless explicitly overridden (e.g., with <code>any</code>).</li> <li>It provides strong guarantees that the emitted JavaScript matches the declared types.</li> <li>TypeScript\u2019s type system is richer and more powerful, supporting advanced features like interfaces, union types, mapped types, and more.</li> </ul> <p>Example in TypeScript:</p> <pre><code>function greet(name: string): string {\n  return \"Hello \" + name;\n}\n</code></pre> <p>Here, if you try to pass a non-string to <code>greet</code>, the TypeScript compiler will raise an error before you run the code.</p>"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#comparing-python-type-hints-and-typescript-types","title":"Comparing Python Type Hints and TypeScript Types","text":"Aspect Python Type Hints TypeScript Types Enforcement Optional, not enforced at runtime Mandatory, enforced at compile time Runtime behavior Ignored by Python interpreter Compiles to JavaScript; runtime uses compiled JS Error detection Requires running external static checkers (e.g., mypy) Built-in compiler checks types automatically Type system richness Simpler, less expressive More complete, flexible, and powerful Integration Separate from runtime, opt-in tooling Integral part of language and build process Use case Improves readability, tooling, optional static checks Prevents many bugs by enforcing types before runtime"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#why-python-doesnt-enforce-types-at-runtime","title":"Why Python Doesn\u2019t Enforce Types at Runtime","text":"<p>Python\u2019s dynamic nature and philosophy prioritize flexibility and simplicity. Type hints were introduced mainly for:</p> <ul> <li>Improving code clarity and documentation.</li> <li>Enabling optional static analysis.</li> <li>Enhancing editor and IDE support.</li> </ul> <p>Since Python code runs directly on the interpreter without a compilation step, enforcing types at runtime would add overhead and complexity, contrary to Python\u2019s design goals.</p>"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#when-do-you-catch-errors","title":"When Do You Catch Errors?","text":"<ul> <li>In TypeScript, type errors are caught during compilation, so you rarely run code with type mismatches.</li> <li>In Python, type errors are caught only if you run a static type checker like <code>mypy</code> before execution. Without it, type hints do not prevent runtime errors.</li> </ul>"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#summary","title":"Summary","text":"<p>While Python type hints and TypeScript types both aim to catch errors early and improve developer experience, they are fundamentally different in enforcement and guarantees:</p> <ul> <li>TypeScript provides a fully integrated, compile-time enforced type system that prevents many errors before running code.</li> <li>Python offers optional type annotations that serve as hints for tools and humans but do not enforce correctness at runtime.</li> </ul> <p>If you want strong static typing guarantees like TypeScript, you must use Python type hints together with static analyzers and testing. Python\u2019s approach offers flexibility and gradual typing but requires discipline and tooling to get the most benefit.</p>"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#further-reading","title":"Further Reading","text":"<ul> <li>Type-checking Python vs TypeScript</li> <li>Is type hinting for Python the same as TypeScript? (Reddit discussion)</li> <li>Python types have an expectations problem (Hacker News)</li> <li>TypeScript vs Python: Which One is Best for You?</li> </ul> <p>Understanding these differences can help you choose the right tools and practices to write safer, clearer code in both Python and JavaScript ecosystems.</p>"},{"location":"pydantic/overview/","title":"Overview","text":""},{"location":"pydantic/overview/#pydantic","title":"Pydantic","text":"<p>Pydantic is a data validation library labeled on its website as the most widely used data validation library for Python.</p> <p>It allows you to model your data in a granular way and perform various types of validation while being firmly rooted in the Python type hinting system. The actual version, V2, has critical parts of the code rewritten in Rust for speed and allows for an excellent developer experience.</p> Quote <p>FastAPI is standing on the shoulders of two powerful Python libraries \u2014 Starlette and Pydantic.</p> <p>While Starlette takes care of the web-related aspects of the framework, often through thin wrappers and utility functions and classes provided by FastAPI, Pydantic is responsible for FastAPI\u2019s phenomenal developer experience.</p> <p>Pydantic is fundamental to FastAPI, and leveraging its powerful capabilities opens up the playing field for all FARM stack developers.</p>"},{"location":"pydantic/overview/#pydantic-basics","title":"Pydantic basics","text":"<p>Unlike some other libraries that provide similar functionality (such as <code>dataclasses</code>), Pydantic provides a base model (aptly named <code>BaseModel</code>) that enables the parsing and validation functionality through inheritance.</p> <p>Besides pure data validation, Pydantic provides other important functionalities to your application. Some of the most widely used operations with Pydantic models are the following:</p> <ul> <li>Data deserialization: Ingesting data into the model</li> <li>Data serialization: Outputting validated data from the model into Python data structures or JSON</li> <li>Data modification: Sanitizing or modifying data on the fly</li> </ul>"},{"location":"pydantic/overview/#reference","title":"Reference","text":"<ul> <li>Full Stack FastAPI, React, and MongoDB, Second edition by Marko Aleksendri\u0107, Ph.D.</li> </ul>"},{"location":"type-hinting/overview/","title":"Overview","text":""},{"location":"type-hinting/overview/#overview","title":"Overview","text":""},{"location":"type-hinting/overview/#python-type-hints","title":"Python Type Hints","text":"<p>Python type hinting is a very important and relatively new feature of the language that facilitates the work of developers, bringing greater robustness and maintainability to the development workflow.</p> <p>Types make your code more readable and understandable, and most importantly, they promote good practices.</p> <p>FastAPI is heavily based on Python type hints. So, before diving into the framework, it is useful to review the basic concepts of type hinting, what they are, how they are implemented, and what their purpose is. This foundational knowledge will help you create robust, maintainable, and scalable APIs with FastAPI. (1)</p> <ol> <li>Full Stack FastAPI, React, and MongoDB, Second edition by Marko Aleksendri\u0107, Ph.D.</li> </ol>"},{"location":"type-hinting/overview/#python-types","title":"Python types","text":"<p>The different types present in a programming language define the language itself\u2014they define its boundaries and set some ground rules for what is possible and, more importantly, what the recommended way of achieving something is. Different types of variables have completely different sets of methods and properties available. For example, while capitalizing a string makes perfect sense, capitalizing a floating number or a list of integers doesn\u2019t.</p> <p>If you have used Python for a while, even for the most mundane tasks, you already know that, like every programming language, it supports different types of data\u2014strings and different numerical types such as integers and floats. It also features a rather rich data structure library: from dictionaries to lists, from sets to tuples, and so on.</p> <p>Python is a dynamically typed language. This means that the type of a variable is not determined at compile time, but at runtime. This feature gives the language itself a lot of flexibility and enables you to declare a variable as a string, use it, and then later on reassign it to a list. However, the ease of changing the variable type can make larger and more complex codebases more prone to errors. Dynamic typing implies that the type of a variable is embedded with the variable itself and is easily modifiable.</p> <p>On the other end of the spectrum lie the so-called statically typed languages: <code>C</code>, <code>C++</code>, <code>Java</code>, <code>Rust</code>, <code>Go</code>, and so on. In these languages, the type of the variable is known at compile time, and it cannot change over time. The type-checking is performed at compile time (so before runtime) and errors are caught before runtime, as the compiler will prevent the program from being compiled.</p> <p>Programming languages are divided into different categories along another, different axis: strongly typed languages and weakly typed languages. This characteristic tells us how much a language restricts its types to operations inherent to those specific types and how easy it is to <code>coerce</code>, or <code>change</code>, a variable from one to another type. Unlike JavaScript, for instance, Python is considered to be on the stronger side of the spectrum, and the interpreter sends strong messages when you try to perform an illegal operation, such as typing the following in a Python interpreter to add a <code>dict</code> type to a number:</p> <pre><code>&gt;&gt;&gt;{}+3\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for +: 'dict' and 'int'\n</code></pre> <p>So, while Python does complain when you attempt to perform unsupported operations, it only does so at runtime, not before executing the code. In fact, there is no indication to you\u2014the developer \u2014 that you are writing code that violates the Python type system.</p>"},{"location":"type-hinting/overview/#type-hinting","title":"Type hinting","text":"<p>As you have seen in the previous section, Python is a dynamically typed language, and types aren\u2019t known until runtime. Since variable types are embedded in the value of the variable itself, as a developer, you cannot know the type of a variable that you encounter in a codebase just by looking at it or inspecting it with your IDE of choice. Fortunately, Python introduced a very sought-out feature starting from version 3.5\u2014type annotations (https://peps.python.org/pep-0484/).</p> <p>Type annotations or hints in Python are an additional syntax that notifies you, the developer, of the expected type of a variable. They are not used by the Python language at runtime, and they do not modify or affect the behavior of your program in any way. You might be wondering what the use of these hints is if the Python interpreter cannot even see them.</p> <p>As it turns out, several important benefits will make almost any codebase much more robust, more maintainable, and future-proof:</p> <ul> <li>Faster code development</li> <li>Knowledge of methods and properties</li> <li>Simplified code development:</li> <li>Automatic code generation</li> <li>Type checkers</li> <li>Easier to read and smaller cognitive load</li> <li>Strongly typed and flexible</li> </ul> <p>Type hinting is at the very base of FastAPI. Coupled with MongoDB\u2019s flexible document schema, it is the backbone of FARM stack development. Type hinting ensures that your application data flow maintains the right data types going in and out of the system at every moment. While this might seem trivial for simpler endpoints\u2014quantities should be integers, names should be strings, and so on\u2014when your data structure becomes more complex, debugging type errors can become very cumbersome.</p> <p>Type hints can also be defined as a formalism\u2014a formal solution to statically (before runtime) indicate the type of a value to a type checker (Mypy, in your case), which will ensure that when the Python runtime encounters your program the types will not be problematic.</p>"},{"location":"type-hinting/overview/#implementing-type-hints","title":"Implementing type hints","text":"<p>Let\u2019s see how you can implement type hinting.</p> <pre><code>mypy==1.10.0\npydantic==2.7.4\n</code></pre> <p>While there are many Python type checkers \u2014 basically tools that perform static analysis of the source code without running it \u2014 we will use mypy as it is easily installable. Later, you will have tools such as Black or Ruff at your disposal. These perform different actions on your source code, including type checking.</p> <pre><code>def print_name_x_times(name: str, times: int) -&gt; None:\n\u202f\u202f\u202f\u202ffor _ in range(times):\n\u202f\u202f\u202f\u202f\u202f\u202f\u202f\u202fprint(name)\n</code></pre> <p>The previous function accepts two parameters, name (a <code>string</code>) and times (an <code>integer</code>), and returns <code>None</code>, while the function prints the given name for a given number of times in the console. If you try to call the function in your code and start typing the arguments, Visual Studio Code (or any IDE with Python type-checking support) will immediately suggest a string as the first positional argument and an integer as the second.</p> <pre><code>def count_users(users: list[str]) -&gt; int:\n\u202f\u202f\u202f\u202freturn len(users)\n</code></pre> <p>So far, you have seen simple annotations that constrain a variable to some Python primitive types including <code>integers</code> and <code>strings</code>. Typing annotations can be more flexible: you might want to allow a variable to accept several variable types, such as an <code>integer</code> and a <code>string</code>.</p> <p>You can achieve this with the use of the Union package from the typing module:</p> <pre><code>from typing import Union\nx: Union(str, int)\n</code></pre> <p>The previously defined <code>x</code> variable can take a string or an integer value. The more modern and concise way of achieving the same functionality is the following:</p> <pre><code>x: str | int\n</code></pre> <p>These annotations mean that the variable x can be an integer or it can take a value of string, which is a different type from an integer.</p> <p>The typing module contains several types of so-called generics, including the following:</p> <ul> <li><code>List</code>: For variables that should be of the list type</li> <li><code>Dict</code>: For dictionaries</li> <li><code>Sequence</code>: For any type of sequence of values</li> <li><code>Callable</code>: For callables, such as functions</li> <li><code>Iterator</code>: Indicates that a function or variable accepts an iterator object (an object that implements the iterator protocol and can be used in a for loop)</li> </ul> Note <p>You are encouraged to explore the <code>typing</code> ==module ==but bear in mind that the types from the module are gradually being imported into Python\u2019s code functionality.</p> <p>For instance, the <code>List</code> type is very useful in working with FastAPI as it allows you to serialize a list of items or resources quickly and efficiently into a JSON output.</p> <pre><code>from typing import List\ndef square_numbers(numbers: List[int]) -&gt; List[int]:\n\u202f\u202f\u202f\u202freturn [number ** 2 for number in numbers]\n# Example usage\ninput_numbers = [1, 2, 3, 4, 5]\nsquared_numbers = square_numbers(input_numbers)\nprint(squared_numbers)\u202f\u202f# Output: [1, 4, 9, 16, 25]\n</code></pre>"},{"location":"type-hinting/overview/#advanced-annotations","title":"Advanced annotations","text":"<p>The annotations you have seen so far are very simple and convey basic information related only to the specific desired type of a variable, function, class argument, or output. Python\u2019s typing system is capable of much more and it can be used to restrict the allowable variables' state further and prevent you, the developer, from creating impossible or illegal states in your code.</p> <p>The most frequently used types are the following:</p> <ul> <li>The <code>Optional</code> type is used for handling optional values and <code>None</code> values in an explicit and developer-friendly way.</li> <li>The <code>Union</code> type allows you to define a union of possible types, such as integers and strings. Modern Python uses the pipe operator (<code>|</code>), as shown in the previous example.</li> <li>The <code>self</code> type is used to indicate that the value will be an instance of a certain class, useful in Pydantic model validators as we will see later.</li> <li>The <code>New</code> type allows developers to define completely new types based on existing types.</li> </ul> <p>This section detailed Python type hints, their purpose, and how they are implemented. The next section will take a deeper look at Pydantic, the workhorse of FastAPI data validation.</p>"},{"location":"type-hinting/overview/#reference","title":"Reference","text":"<ul> <li>Full Stack FastAPI, React, and MongoDB, Second edition by Marko Aleksendri\u0107, Ph.D.</li> </ul>"},{"location":"type-hinting/typing-module/","title":"Typing Module","text":""},{"location":"type-hinting/typing-module/#the-typing-module","title":"The <code>typing</code> module","text":"<p>The <code>typing</code> module is built-in since <code>Python 3.5</code> and remains essential for advanced annotations, but for common generics, built-in types are preferred in modern Python versions.</p> <p>The <code>typing</code> module has been included in the Python standard library since <code>Python 3.5</code>, so you do not need to install it separately if you are using <code>Python 3.5</code> or newer.</p> <p>For Python versions older than <code>3.5</code>, the typing module is available as a backport package on PyPI that you can install manually.</p> In summary <ul> <li>Python 3.5 and later: <code>typing</code> is built-in, no installation required.</li> <li>Before Python 3.5: install the <code>typing</code> package from PyPI if you want to use type hints.</li> </ul> <p>Additionally, newer features added to typing in recent Python releases may require the <code>typing_extensions</code> package to backport those features to older Python versions.</p>"},{"location":"type-hinting/typing-module/#type-hinting-and-type-checking-with-mypy","title":"Type hinting and type checking with mypy","text":"<p>In the first section of this chapter, we said that Python was a dynamically typed language: the interpreter doesn't check types at compile time but rather at runtime. This makes the language a bit more flexible and the developer a bit more efficient. However, if you are experienced with that kind of language, you probably know that it's easy to produce errors and bugs in this context: forgetting arguments and type mismatch.</p> <p>This is why Python introduced type hinting starting with version 3.5. The goal is to provide a syntax to annotate the source code with type annotations: each <code>variable</code>, <code>function</code>, and <code>class</code> can be annotated to give indications about the types they expect. This doesn't mean that Python becomes a statically typed language. Those annotations remain completely optional and are ignored by the interpreter. However, those annotations can be used by static-type checkers, which will check whether your code is valid and consistent following the annotations. Hence, it greatly helps you to reduce errors and write self-explanatory code.</p> <p>One of those tools, mypy, is widely used by the community in this context.</p> <pre><code>pip install mypy\n</code></pre> <ul> <li> pg-48</li> <li>Github: mypy</li> </ul> <p>You understand the basics of type hinting in Python. We'll now review more advanced examples, especially with non-scalar types.</p>"},{"location":"type-hinting/typing-module/#the-typing-module_1","title":"The typing module","text":"<p>So far, we've seen how to annotate variables for scalar types such as str or int. But we've seen that there are data structures such as lists and dictionaries that are widely used in Python. For those and other types of utilities, Python introduced the typing module.</p> <p>In the following example, we'll show how to type hint basic data structures in Python:</p> <pre><code>from typing import Dict, List, Set, Tuple\n\nl: List[int] = [1, 2, 3, 4, 5]\n\nt: Tuple[int, str, float] = (1, \"hello\", 3.14)\n\ns: Set[int] = {1, 2, 3, 4, 5}\n\nd: Dict[str, int] = {\"a\": 1, \"b\": 2, \"c\": 3}\n</code></pre> <p>The <code>typing</code> module contains classes for type hinting <code>lists</code>, <code>tuples</code>, <code>sets</code>, and <code>dictionaries</code>.</p> <p>You simply have to import it and use it in your annotations. In this case, those classes expect you to provide the type of the values composing your structure. It's the same as the well-known concept of generics in object-oriented programming. In Python, they are defined using square brackets.</p>"},{"location":"type-hinting/typing-module/#reference","title":"Reference","text":"<ul> <li>Building Data Science Applications with FastAPI by Fran\u00e7ois Voron</li> </ul>"},{"location":"blog/archive/2024/","title":"2024","text":""}]}