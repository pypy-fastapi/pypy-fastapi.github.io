{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Fastapi","text":""},{"location":"#welcome-to-fastapi","title":"Welcome to Fastapi","text":"<p>FastAPI is a modern, fast (high-performance) web framework for building APIs with Python <code>3.6+</code> based on standard Python type hints.</p> <ul> <li>Sebasti\u00e1n Ram\u00edrez, creator of FastAPI</li> </ul> A FastAPI Application <ul> <li>The FastAPI framework: <code>pip install fastapi</code></li> <li>The Uvicorn web server: <code>pip install uvicorn</code></li> <li>The HTTPie text web client: <code>pip install httpie</code></li> <li>The Requests synchronous web client package: <code>pip install requests</code></li> <li>The HTTPX synchronous/asynchronous web client package: <code>pip install httpx</code></li> </ul> <p>Although curl is the best known text web client, I think HTTPie is easier to use. Also, it defaults to JSON encoding and decoding, which is a better match for FastAPI.</p> Identify the Core 20% of FastAPI <p>FastAPI is a Python framework for building APIs quickly with high performance. The critical 20% of FastAPI to learn includes:</p> <ul> <li>Routing and Endpoints: Understand how to define routes using <code>@app.get()</code>, <code>@app.post()</code>, etc.</li> <li>Request and Response Handling: Learn to handle query parameters, path parameters, and JSON request bodies, and return responses with proper status codes.</li> <li>Pydantic Models: Master Pydantic for data validation and serialization.</li> <li>Dependency Injection: Use FastAPI\u2019s dependency system for reusable logic (e.g., authentication, database connections).</li> <li>Async/Await: Grasp asynchronous programming to leverage FastAPI\u2019s performance (e.g., <code>async def</code> for endpoints).</li> </ul> <p>Normal Python execution is synchronous: one thing at a time, in the order specified by the code. Sometimes we want to be asynchronous: do a little of one thing, then a little of another thing, back to the first thing, and so on. If all our code uses the CPU to calculate things (CPU bound), there\u2019s really no spare time to be asynchronous. But if we perform something that makes the CPU wait for an external thing to complete (I/O bound), we can be asynchronous.</p> <p>Asynchronous systems provide an event loop: requests for slow operations are sent and noted, but we don\u2019t hold up the CPU waiting for their responses. Instead, some immediate processing is done on each pass through the loop, and any responses that came in during that time are handled in the next pass.(1)</p> <ol> <li>FastAPI - Modern Python Web Development by Bill Lubanovic, pg-8</li> </ol>"},{"location":"#status-code","title":"Status Code","text":"<p>By default, FastAPI returns a <code>200</code> status code; exceptions raise <code>4xx</code> codes.</p>"},{"location":"#automated-documentation","title":"Automated Documentation","text":"<p>Convince your browser to visit the URL <code>http://localhost:8000/docs</code>.</p> <p>Where did that come from?</p> <p>FastAPI generates an OpenAPI specification from your code, and includes this page to display and test all your endpoints. This is just one ingredient of its secret sauce.</p>"},{"location":"#making-a-website","title":"Making a Website","text":"<p>The full service will have three layers, as I\u2019ve discussed earlier:</p> <ul> <li>Web : The web interface</li> <li>Service : The business logic</li> <li>Data : The precious DNA of the whole thing</li> </ul> <p>Plus the web service will have these cross-layer components:</p> <ul> <li>Model : Pydantic data definitions</li> <li>Tests : Unit, integration, and end-to-end tests</li> </ul> Interlude: Top-Down, Bottom-Up, Middle-Out? <p>When designing a website, you could start from one of the following:</p> <ul> <li>The Web layer and work down</li> <li>The Data layer and work up</li> <li>The Service layer and work out in both directions</li> </ul> <p>Do you already have a database, installed and loaded with data, and are just pining for a way to share it with the world? If so, you may want to tackle the Data layer\u2019s code and tests first, then the Service layer, and write the Web layer last.</p> <p>If you\u2019re following domain-driven design, you might start in the middle Service layer, defining your core entities and data models. Or you may want to evolve the web interface first, and fake calls to the lower layers until you know what you\u2019ll expect of them.</p>"},{"location":"#books","title":"Books","text":""},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""}]}