{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Fastapi","text":""},{"location":"#welcome-to-fastapi","title":"Welcome to Fastapi","text":"<p>FastAPI is a modern, fast (high-performance) web framework for building APIs with Python <code>3.6+</code> based on standard Python type hints.(1)</p> <ol> <li> <ul> <li>Sebasti\u00e1n Ram\u00edrez, creator of FastAPI</li> </ul> </li> </ol> A FastAPI Application <ul> <li>The FastAPI framework: <code>pip install fastapi</code></li> <li>The Uvicorn web server: <code>pip install uvicorn</code></li> <li>The HTTPie text web client: <code>pip install httpie</code></li> <li>The Requests synchronous web client package: <code>pip install requests</code></li> <li>The HTTPX synchronous/asynchronous web client package: <code>pip install httpx</code></li> </ul> <p>Although curl is the best known text web client, I think HTTPie is easier to use. Also, it defaults to JSON encoding and decoding, which is a better match for FastAPI.</p> <p>FastAPI is heavily based on Python type hints. So, before diving into the framework, it is useful to review the basic concepts of type hinting, what they are, how they are implemented, and what their purpose is. This foundational knowledge will help you create robust, maintainable, and scalable APIs with FastAPI. (1)</p> <ol> <li> <p>Full Stack FastAPI, React, and MongoDB, Second edition by Marko Aleksendri\u0107, Ph.D.</p> <p>By the end of this chapter, you will have a deep understanding of the role of type annotations in Python with FastAPI and Pydantic. Pydantic is a modern Python library that enforces type hints at runtime, provides customizable and user-friendly errors when data is invalid, and allows definition of data structures using Python type annotations.</p> <p>You will be able to model your data with precision, leveraging the advanced features of Pydantic to make you a better and more productive FastAPI developer.</p> </li> </ol> Identify the Core 20% of FastAPI <p>FastAPI is a Python framework for building APIs quickly with high performance. The critical 20% of FastAPI to learn includes:</p> <ul> <li>Routing and Endpoints: Understand how to define routes using <code>@app.get()</code>, <code>@app.post()</code>, etc.</li> <li>Request and Response Handling: Learn to handle query parameters, path parameters, and JSON request bodies, and return responses with proper status codes.</li> <li>Pydantic Models: Master Pydantic for data validation and serialization.</li> <li>Dependency Injection: Use FastAPI\u2019s dependency system for reusable logic (e.g., authentication, database connections).</li> <li>Async/Await: Grasp asynchronous programming to leverage FastAPI\u2019s performance (e.g., <code>async def</code> for endpoints).</li> </ul> <p>Normal Python execution is synchronous: one thing at a time, in the order specified by the code. Sometimes we want to be asynchronous: do a little of one thing, then a little of another thing, back to the first thing, and so on. If all our code uses the CPU to calculate things (CPU bound), there\u2019s really no spare time to be asynchronous. But if we perform something that makes the CPU wait for an external thing to complete (I/O bound), we can be asynchronous.</p> <p>Asynchronous systems provide an event loop: requests for slow operations are sent and noted, but we don\u2019t hold up the CPU waiting for their responses. Instead, some immediate processing is done on each pass through the loop, and any responses that came in during that time are handled in the next pass.(1)</p> <ol> <li>FastAPI - Modern Python Web Development by Bill Lubanovic, pg-8</li> </ol>"},{"location":"#status-code","title":"Status Code","text":"<p>By default, FastAPI returns a <code>200</code> status code; exceptions raise <code>4xx</code> codes.</p>"},{"location":"#automated-documentation","title":"Automated Documentation","text":"<p>Convince your browser to visit the URL <code>http://localhost:8000/docs</code>.</p> <p>Where did that come from?</p> <p>FastAPI generates an OpenAPI specification from your code, and includes this page to display and test all your endpoints. This is just one ingredient of its secret sauce.</p>"},{"location":"#making-a-website","title":"Making a Website","text":"<p>The full service will have three layers, as I\u2019ve discussed earlier:</p> <ul> <li>Web : The web interface</li> <li>Service : The business logic</li> <li>Data : The precious DNA of the whole thing</li> </ul> <p>Plus the web service will have these cross-layer components:</p> <ul> <li>Model : Pydantic data definitions</li> <li>Tests : Unit, integration, and end-to-end tests</li> </ul> Interlude: Top-Down, Bottom-Up, Middle-Out? <p>When designing a website, you could start from one of the following:</p> <ul> <li>The Web layer and work down</li> <li>The Data layer and work up</li> <li>The Service layer and work out in both directions</li> </ul> <p>Do you already have a database, installed and loaded with data, and are just pining for a way to share it with the world? If so, you may want to tackle the Data layer\u2019s code and tests first, then the Service layer, and write the Web layer last.</p> <p>If you\u2019re following domain-driven design, you might start in the middle Service layer, defining your core entities and data models. Or you may want to evolve the web interface first, and fake calls to the lower layers until you know what you\u2019ll expect of them.</p>"},{"location":"#server","title":"SERVER","text":"<p>For FastAPI to run, it needs a server. In this case, a server is a software designed to serve web applications (or REST APIs). FastAPI relies on the asynchronous server gateway interface (ASGI), which enables async non-blocking applications, which is something you can completely use with your FastAPI capabilities.</p> <p>At present, the FastAPI documentation lists three compatible Python ASGI-compatible servers: Uvicorn, Hypercorn, and Daphne. This book will focus on Uvicorn, the most widely used and recommended option for working with FastAPI. Uvicorn offers high performance, and if you get stuck, there\u2019s extensive documentation available online.</p> <pre><code>pip install fastapi uvicorn\n</code></pre> <ul> <li>Full Stack FastAPI, React, and MongoDB, Second edition by Marko Aleksendri\u0107, pg: 73</li> </ul>"},{"location":"#farm-stack-fastapi-react-and-mongodb","title":"FARM Stack - FastAPI, React, and MongoDB","text":""},{"location":"#books","title":"Books","text":""},{"location":"fastapi-shell/","title":"CLI","text":""},{"location":"fastapi-shell/#fastapi-shell","title":"Fastapi shell","text":"<p>FastAPI itself doesn\u2019t come with a built-in shell like Django\u2019s <code>manage.py shell</code>, but you can easily create a similar development shell using one of the following approaches:</p>"},{"location":"fastapi-shell/#option-1-use-ipython-or-ptpython-with-app-context","title":"\u2705 Option 1: Use <code>ipython</code> or <code>ptpython</code> with App Context","text":"<p>Step 1: Install a better interactive shell</p> <pre><code>pip install ipython\n</code></pre> <p>Or:</p> <pre><code>pip install ptpython\n</code></pre>"},{"location":"fastapi-shell/#step-2-create-a-shellpy-script","title":"Step 2: Create a <code>shell.py</code> script","text":"<p>Create a file <code>shell.py</code> at the root of your FastAPI project:</p> <pre><code># shell.py\nfrom pymongo import MongoClient\nfrom myapp.main import app  # import your FastAPI app\n\n# Set up your Mongo client and DB\nclient = MongoClient(\"mongodb://localhost:27017\")\ndb = client[\"mydatabase\"]\ncollection = db[\"mycollection\"]\n\n# Add any other services or models you want to pre-load\n\n# Start an interactive shell\nif __name__ == \"__main__\":\n    try:\n        from IPython import embed\n        embed(using=False)  # IPython shell\n    except ImportError:\n        import code\n        code.interact(local=locals())\n</code></pre> <p>Now run:</p> <pre><code>python shell.py\n</code></pre> <p>You\u2019ll get an interactive shell with <code>app</code>, <code>db</code>, and <code>collection</code> loaded.</p>"},{"location":"fastapi-shell/#option-2-use-typer-fastapis-cli-sibling","title":"\u2705 Option 2: Use <code>typer</code> (FastAPI\u2019s CLI sibling)","text":"<p>FastAPI\u2019s creator also built Typer for CLI apps. You can build a CLI that includes a <code>shell</code> command:</p> <pre><code>pip install typer[all]\n</code></pre> <p>Then create <code>cli.py</code>:</p> <pre><code>import typer\nfrom pymongo import MongoClient\nfrom myapp.main import app\n\ncli = typer.Typer()\n\n@cli.command()\ndef shell():\n    \"\"\"Launch an interactive shell with app context.\"\"\"\n    client = MongoClient(\"mongodb://localhost:27017\")\n    db = client[\"mydatabase\"]\n    collection = db[\"mycollection\"]\n\n    # Start an IPython shell\n    try:\n        from IPython import embed\n        embed(using=False)\n    except ImportError:\n        import code\n        code.interact(local=locals())\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Run with:</p> <pre><code>python cli.py shell\n</code></pre>"},{"location":"fastapi-shell/#why-this-matters","title":"\ud83e\udde0 Why This Matters","text":"<ul> <li>No need for full Django-like ORM to benefit from a shell.</li> <li>You can preload your FastAPI app, DB clients, models, or settings into a sandboxed shell.</li> <li>Super useful for debugging or running quick queries.</li> </ul>"},{"location":"fastapi-shell/#my-opinion","title":"My Opinion","text":"<p>I personally perfer to use <code>ptpython</code> because i have installed and used it. I like its theme.</p> <pre><code>(backend) ninja@ninja: pipenv shell\n\n(backend) ninja@ninja: pipenv install ptpython\n\n(backend) ninja@ninja: ptpython\n\n&gt;&gt;&gt; import pymongo\n&gt;&gt;&gt; dir(pymongo)\n&gt;&gt;&gt; help(pymongo)\n</code></pre>"},{"location":"fastapi-shell/#summary-table","title":"\ud83e\udde0 Summary Table","text":"Feature IPython ptpython Tab completion \u2705 Yes \u2705 Yes Syntax highlighting \u2705 Limited (in prompt only) \u2705 Full Magic commands (<code>%</code>) \u2705 Yes \u274c No Autocomplete suggestions \u2705 Yes \u2705 Enhanced Built-in help/doc sidebar \u274c No \u2705 Yes Jupyter integration \u2705 Yes \u274c No UI customization \u26a0\ufe0f Limited \u2705 Yes (keybindings, themes) Multiline editing \u26a0\ufe0f Basic \u2705 Rich support"},{"location":"FastAPI/dir-function/","title":"dir()","text":""},{"location":"FastAPI/dir-function/#dir","title":"dir()","text":"<pre><code>&gt;&gt;&gt; import fastapi\n&gt;&gt;&gt; dir(fastapi)\n['APIRouter', 'BackgroundTasks', 'Body', 'Cookie', 'Depends', 'FastAPI', 'File', 'Form', 'HTTPException', 'Header', 'Path', 'Query', 'Request', 'Response', 'Security', 'UploadFile', 'WebSocket', 'WebSocketDisconnect', 'WebSocketException', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '__version__', '_compat', 'applications', 'background', 'concurrency', 'datastructures', 'dependencies', 'encoders', 'exception_handlers', 'exceptions', 'logger', 'openapi', 'param_functions', 'params', 'requests', 'responses', 'routing', 'security', 'status', 'types', 'utils', 'websockets']\n</code></pre> <p>Here's a categorized breakdown of the items returned by <code>dir(fastapi)</code> to help you better understand and remember what each item represents. We'll group them into meaningful categories:</p>"},{"location":"FastAPI/dir-function/#core-classes-functions","title":"\u2705 Core Classes &amp; Functions","text":"<p>These are commonly used when building FastAPI apps.</p> <ul> <li><code>FastAPI</code> \u2013 The main application class used to create your app.</li> <li><code>APIRouter</code> \u2013 Used to create modular, reusable route groups.</li> <li><code>Request</code>, <code>Response</code> \u2013 Represent HTTP request and response objects.</li> <li><code>Depends</code> \u2013 Used for dependency injection.</li> </ul>"},{"location":"FastAPI/dir-function/#parameter-and-data-handling","title":"\ud83d\udee0\ufe0f Parameter and Data Handling","text":"<p>These are used to extract and validate request data from different sources.</p> <ul> <li><code>Body</code>, <code>Query</code>, <code>Path</code>, <code>Header</code>, <code>Cookie</code> \u2013 Helpers for declaring where data should come from in a request.</li> <li><code>Form</code>, <code>File</code>, <code>UploadFile</code> \u2013 Used for form submissions and file uploads.</li> </ul>"},{"location":"FastAPI/dir-function/#security","title":"\ud83d\udd12 Security","text":"<p>Built-in tools for managing authentication and authorization.</p> <ul> <li><code>Security</code> \u2013 Declares dependencies with security scopes.</li> </ul>"},{"location":"FastAPI/dir-function/#error-handling","title":"\u26d4 Error Handling","text":"<p>Raise or handle exceptions.</p> <ul> <li><code>`HTTPException</code> \u2013 The standard way to raise HTTP errors.</li> <li><code>`WebSocketException</code>, <code>WebSocketDisconnect</code> \u2013 Exceptions for WebSocket handling.</li> </ul>"},{"location":"FastAPI/dir-function/#background-and-concurrency-tools","title":"\ud83d\udd01 Background and Concurrency Tools","text":"<p>Useful for non-blocking tasks.</p> <ul> <li><code>BackgroundTasks</code> \u2013 Run tasks after returning a response.</li> <li><code>concurrency</code> \u2013 Tools for async/threaded operations.</li> </ul>"},{"location":"FastAPI/dir-function/#websocket-support","title":"\ud83c\udf10 WebSocket Support","text":"<p>Related to real-time, bi-directional communication.</p> <ul> <li><code>WebSocket</code> \u2013 Represents a WebSocket connection.</li> <li>(Also uses <code>WebSocketException</code>, <code>WebSocketDisconnect</code> from above)</li> </ul>"},{"location":"FastAPI/dir-function/#modulessubmodules","title":"\ud83e\udde9 Modules/Submodules","text":"<p>These are internal FastAPI modules, mostly used behind the scenes or for advanced use.</p> <ul> <li><code>applications</code> \u2013 Application-level tools.</li> <li><code>background</code> \u2013 Background task management.</li> <li><code>dependencies</code> \u2013 Dependency injection framework.</li> <li><code>encoders</code> \u2013 JSON and Pydantic encoding helpers.</li> <li><code>exception_handlers</code>, <code>exceptions</code> \u2013 Custom exception logic.</li> <li><code>logger</code> \u2013 Logging utilities.</li> <li><code>openapi</code> \u2013 OpenAPI schema generation.</li> <li><code>param_functions</code>, <code>params</code> \u2013 Parameter declaration utilities.</li> <li><code>requests</code>, <code>responses</code> \u2013 Request/response abstractions.</li> <li><code>routing</code> \u2013 Route handling.</li> <li><code>security</code> \u2013 Security-related helpers.</li> <li><code>status</code> \u2013 HTTP status codes (like <code>status.HTTP_404_NOT_FOUND</code>).</li> <li><code>types</code>, <code>utils</code>, <code>datastructures</code>, <code>_compat</code>, <code>websockets</code> \u2013 Miscellaneous utilities, types, and compatibility helpers.</li> </ul>"},{"location":"FastAPI/dir-function/#python-built-ins-and-metadata","title":"\ud83e\uddec Python Built-ins and Metadata","text":"<p>These are automatically included by Python.</p> <ul> <li><code>__builtins__</code>, <code>__cached__</code>, <code>__doc__</code>, <code>__file__</code>, <code>__loader__</code>, <code>__name__</code>, <code>__package__</code>, <code>__path__</code>, <code>__spec__</code>, <code>__version__</code></li> </ul>"},{"location":"FastAPI/dir-function/#summary-table","title":"Summary Table","text":"Category Examples Core Classes <code>FastAPI</code>, <code>APIRouter</code>, <code>Request</code>, <code>Response</code>, <code>Depends</code> Parameter Handling <code>Body</code>, <code>Query</code>, <code>Path</code>, <code>Header</code>, <code>Cookie</code>, <code>Form</code>, <code>File</code>, <code>UploadFile</code> Security <code>Security</code> Error Handling <code>HTTPException</code>, <code>WebSocketException</code>, <code>WebSocketDisconnect</code> Background &amp; Concurrency <code>BackgroundTasks</code>, <code>concurrency</code> WebSocket <code>WebSocket</code> Submodules <code>openapi</code>, <code>routing</code>, <code>responses</code>, <code>security</code>, <code>logger</code>, etc. Built-ins/Metadata <code>__version__</code>, <code>__doc__</code>, <code>__name__</code>, etc."},{"location":"FastAPI/installation/","title":"Installation","text":""},{"location":"FastAPI/installation/#installation","title":"Installation","text":"<p>FastAPI works with Python, so you need to check your Python version before using it. This is an important step for setting up FastAPI.</p>"},{"location":"FastAPI/installation/#installing-fastapi-and-uvicorn","title":"Installing FastAPI and Uvicorn","text":"<p>With Python set up, the next step is installing FastAPI and Uvicorn. FastAPI is the framework we\u2019ll use to build our applications, and Uvicorn is an ASGI server that runs and serves our FastAPI applications.</p> <pre><code>$ pip install fastapi[all]\n</code></pre> <p>This command installs FastAPI along with its recommended dependencies, including Uvicorn.</p> <p>To verify the installation, you can simply run <code>uvicorn --version</code> from the terminal. (1)</p> <ol> <li>FastAPI Cookback by Giunio De Luca, pg: 4</li> </ol>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/","title":"Python Type Hints vs TypeScript: Understanding the Differences and Similarities","text":""},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#python-type-hints-vs-typescript-understanding-the-differences-and-similarities","title":"Python Type Hints vs TypeScript: Understanding the Differences and Similarities","text":"<p>Type hints in Python and TypeScript\u2019s static typing share a common goal: helping developers catch errors before running the code. However, they differ significantly in how they work and what guarantees they provide.</p> <p>This blog explores these differences and explains why Python\u2019s type hints are not quite the same as TypeScript\u2019s type system, even though they serve related purposes.</p>"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#what-are-type-hints-in-python","title":"What Are Type Hints in Python?","text":"<p>Python introduced type hints (or type annotations) starting with version 3.5 to allow developers to optionally specify expected types for variables, function parameters, and return values. For example:</p> <pre><code>def greet(name: str) -&gt; str:\n    return \"Hello \" + name\n</code></pre> <p>These annotations improve code readability and enable static analysis tools like <code>mypy</code> to check for type inconsistencies before runtime.</p> <p>Key points about Python type hints:</p> <ul> <li>They are optional and do not affect runtime behavior.</li> <li>Python itself does not enforce these types when the code runs.</li> <li>Static type checkers must be run separately to detect type errors.</li> <li>Type hints help IDEs provide better autocompletion and error detection.</li> <li>They serve as documentation and tooling aids rather than strict contracts.</li> </ul>"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#what-is-typescripts-type-system","title":"What Is TypeScript\u2019s Type System?","text":"<p>TypeScript is a statically typed superset of JavaScript that compiles to plain JavaScript. Its type system is integrated into the language and build process, meaning:</p> <ul> <li>Type checking happens at compile time.</li> <li>Code with type errors will not compile unless explicitly overridden (e.g., with <code>any</code>).</li> <li>It provides strong guarantees that the emitted JavaScript matches the declared types.</li> <li>TypeScript\u2019s type system is richer and more powerful, supporting advanced features like interfaces, union types, mapped types, and more.</li> </ul> <p>Example in TypeScript:</p> <pre><code>function greet(name: string): string {\n  return \"Hello \" + name;\n}\n</code></pre> <p>Here, if you try to pass a non-string to <code>greet</code>, the TypeScript compiler will raise an error before you run the code.</p>"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#comparing-python-type-hints-and-typescript-types","title":"Comparing Python Type Hints and TypeScript Types","text":"Aspect Python Type Hints TypeScript Types Enforcement Optional, not enforced at runtime Mandatory, enforced at compile time Runtime behavior Ignored by Python interpreter Compiles to JavaScript; runtime uses compiled JS Error detection Requires running external static checkers (e.g., mypy) Built-in compiler checks types automatically Type system richness Simpler, less expressive More complete, flexible, and powerful Integration Separate from runtime, opt-in tooling Integral part of language and build process Use case Improves readability, tooling, optional static checks Prevents many bugs by enforcing types before runtime"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#why-python-doesnt-enforce-types-at-runtime","title":"Why Python Doesn\u2019t Enforce Types at Runtime","text":"<p>Python\u2019s dynamic nature and philosophy prioritize flexibility and simplicity. Type hints were introduced mainly for:</p> <ul> <li>Improving code clarity and documentation.</li> <li>Enabling optional static analysis.</li> <li>Enhancing editor and IDE support.</li> </ul> <p>Since Python code runs directly on the interpreter without a compilation step, enforcing types at runtime would add overhead and complexity, contrary to Python\u2019s design goals.</p>"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#when-do-you-catch-errors","title":"When Do You Catch Errors?","text":"<ul> <li>In TypeScript, type errors are caught during compilation, so you rarely run code with type mismatches.</li> <li>In Python, type errors are caught only if you run a static type checker like <code>mypy</code> before execution. Without it, type hints do not prevent runtime errors.</li> </ul>"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#summary","title":"Summary","text":"<p>While Python type hints and TypeScript types both aim to catch errors early and improve developer experience, they are fundamentally different in enforcement and guarantees:</p> <ul> <li>TypeScript provides a fully integrated, compile-time enforced type system that prevents many errors before running code.</li> <li>Python offers optional type annotations that serve as hints for tools and humans but do not enforce correctness at runtime.</li> </ul> <p>If you want strong static typing guarantees like TypeScript, you must use Python type hints together with static analyzers and testing. Python\u2019s approach offers flexibility and gradual typing but requires discipline and tooling to get the most benefit.</p>"},{"location":"blog/2024/05/13/python-type-hints-vs-typescript-understanding-the-differences-and-similarities/#further-reading","title":"Further Reading","text":"<ul> <li>Type-checking Python vs TypeScript</li> <li>Is type hinting for Python the same as TypeScript? (Reddit discussion)</li> <li>Python types have an expectations problem (Hacker News)</li> <li>TypeScript vs Python: Which One is Best for You?</li> </ul> <p>Understanding these differences can help you choose the right tools and practices to write safer, clearer code in both Python and JavaScript ecosystems.</p>"},{"location":"blog/2024/05/13/understanding-python-annotations-and-type-hints/","title":"Understanding Python Annotations and Type Hints","text":""},{"location":"blog/2024/05/13/understanding-python-annotations-and-type-hints/#understanding-python-annotations-and-type-hints","title":"Understanding Python Annotations and Type Hints","text":"<p>Python has introduced a powerful feature that helps developers write clearer, more maintainable code: type annotations, also known as type hints. But are annotations and type hints the same thing? In this post, we'll explore what they are, how they relate, and how you can document your Python projects using MkDocs.</p>"},{"location":"blog/2024/05/13/understanding-python-annotations-and-type-hints/#what-are-python-annotations-and-type-hints","title":"What Are Python Annotations and Type Hints?","text":"<p>In Python, annotations refer to the syntax that allows you to attach metadata to function parameters and return values. When these annotations specify types, they are called type hints. Essentially, annotations and type hints are the same feature, used interchangeably to indicate the expected data types in your code.</p> <p>For example:</p> <pre><code>def greet(name: str) -&gt; str:\n    return \"Hello \" + name\n</code></pre> <p>Here, <code>name: str</code> and <code>-&gt; str</code> are type annotations or type hints, signaling that <code>name</code> should be a string and the function returns a string.</p>"},{"location":"blog/2024/05/13/understanding-python-annotations-and-type-hints/#why-use-type-hints","title":"Why Use Type Hints?","text":"<ul> <li>Improved readability: They make your code easier to understand by explicitly stating what types are expected.</li> <li>Better tooling: Editors and IDEs can use type hints to provide better autocompletion and error detection.</li> <li>Static analysis: Tools like mypy can check your code for type consistency before runtime.</li> <li>Documentation: Type hints serve as a form of documentation embedded directly in your code.</li> </ul> <p>Note that Python itself does not enforce these types at runtime; they are mainly for humans and tools.</p>"},{"location":"blog/2024/05/13/understanding-python-annotations-and-type-hints/#summary","title":"Summary:","text":"<ul> <li>Type hints provide metadata about expected types in your code.</li> <li>Static type checkers use these hints to find type errors before execution.</li> <li>This helps you identify bugs early and improves code maintainability.</li> <li>Python does not enforce types at runtime; type hints are optional and for tooling support only.</li> </ul> <p>This proactive error detection is one of the primary benefits of adopting type hints in Python development</p>"},{"location":"blog/2025/06/02/how-fastapi-really-works-under-the-hood-of-fastapi/","title":"How FastAPI Really Works: Under the Hood of FastAPI","text":""},{"location":"blog/2025/06/02/how-fastapi-really-works-under-the-hood-of-fastapi/#how-fastapi-really-works-under-the-hood-of-fastapi","title":"How FastAPI Really Works: Under the Hood of FastAPI","text":"<p>FastAPI is a modern, high-performance web framework for building APIs with Python, based on standard Python type hints. Under the hood, it's powered by Starlette for web handling and Pydantic (now superseded by Pydantic v2 using <code>pydantic-core</code>) for data validation. Here\u2019s a breakdown of how it works internally:</p> <p>FastAPI is an abstraction layer that uses Starlette as its foundational web toolkit.</p>"},{"location":"blog/2025/06/02/how-fastapi-really-works-under-the-hood-of-fastapi/#core-components-of-fastapi","title":"\ud83d\udd27 Core Components of FastAPI","text":""},{"location":"blog/2025/06/02/how-fastapi-really-works-under-the-hood-of-fastapi/#1-asgi-with-starlette","title":"1. ASGI with Starlette","text":"<ul> <li> <p>FastAPI is built on top of Starlette, an ASGI (Asynchronous Server Gateway Interface) framework.</p> </li> <li> <p>ASGI allows asynchronous and synchronous code to coexist, supporting fast, non-blocking I/O.</p> </li> <li> <p>Starlette handles:</p> <ul> <li>Routing</li> <li>Middleware</li> <li>Background tasks</li> <li>WebSockets</li> <li>Request/response handling</li> </ul> </li> </ul>"},{"location":"blog/2025/06/02/how-fastapi-really-works-under-the-hood-of-fastapi/#2-request-lifecycle-in-fastapi","title":"2. Request Lifecycle in FastAPI","text":"<ol> <li> <p>Client makes a request (e.g., HTTP GET <code>/items/5</code>)</p> </li> <li> <p>ASGI server (e.g., Uvicorn) receives it and passes it to FastAPI.</p> </li> <li> <p>FastAPI:</p> <ul> <li> <p>Matches the route using Starlette's router</p> </li> <li> <p>Extracts and validates path/query/body parameters using Pydantic</p> </li> <li> <p>Invokes the corresponding endpoint function (sync or async)</p> </li> <li> <p>Converts the return value (e.g., dict or Pydantic model) into a proper HTTP Response</p> </li> <li> <p>Handles exceptions with registered exception handlers</p> </li> </ul> </li> </ol>"},{"location":"blog/2025/06/02/how-fastapi-really-works-under-the-hood-of-fastapi/#3-dependency-injection-system","title":"3. Dependency Injection System","text":"<ul> <li> <p>FastAPI provides a powerful, lightweight dependency injection (DI) mechanism using Python's <code>Depends()</code>.</p> </li> <li> <p>At runtime, it builds a dependency graph, resolves them recursively, and injects the results into your endpoint function.</p> </li> <li> <p>Dependencies can be:</p> <ul> <li>Request-scoped (e.g., user auth)</li> <li>Singleton (e.g., DB connections)</li> <li>Background tasks, cleanup functions, etc.</li> </ul> </li> </ul>"},{"location":"blog/2025/06/02/how-fastapi-really-works-under-the-hood-of-fastapi/#4-pydantic-for-data-parsing-validation","title":"4. Pydantic for Data Parsing &amp; Validation","text":"<ul> <li> <p>FastAPI uses Pydantic models to:</p> <ul> <li>Parse and validate incoming JSON or query/path params</li> <li>Generate OpenAPI documentation</li> </ul> </li> <li> <p>It creates schemas from type hints and validates input automatically.</p> </li> <li> <p>It ensures that the request input is well-formed before your business logic is run</p> </li> </ul>"},{"location":"blog/2025/06/02/how-fastapi-really-works-under-the-hood-of-fastapi/#5-openapi-swagger-documentation","title":"5. OpenAPI / Swagger Documentation","text":"<ul> <li> <p>FastAPI automatically generates:</p> <ul> <li>OpenAPI schema (<code>/openapi.json</code>)</li> <li>Interactive Swagger UI (<code>/docs</code>)</li> <li>ReDoc UI (<code>/redoc</code>)</li> </ul> </li> <li> <p>It introspects:</p> <ul> <li>Function signatures</li> <li>Type hints</li> <li>Descriptions/docstrings</li> </ul> </li> <li> <p>This makes FastAPI self-documenting.</p> </li> </ul>"},{"location":"blog/2025/06/02/how-fastapi-really-works-under-the-hood-of-fastapi/#internals-breakdown-with-flow","title":"\u2699\ufe0f Internals Breakdown with Flow","text":"<pre><code>[Client] \u2500\u2500\u25ba [Uvicorn (ASGI Server)] \u2500\u2500\u25ba [Starlette Router] \u2500\u2500\u25ba [FastAPI Endpoint Handler]\n                                           \u2502\n                                           \u251c\u2500\u25ba Dependency Injection\n                                           \u251c\u2500\u25ba Pydantic Parsing &amp; Validation\n                                           \u2514\u2500\u25ba Type-aware function invocation\n                                                    \u2502\n                                                [Return Value]\n                                                    \u25bc\n                                         [Starlette Response Builder] \u2500\u2500\u25ba [Client]\n</code></pre>"},{"location":"blog/2025/06/02/how-fastapi-really-works-under-the-hood-of-fastapi/#key-advantages-from-internal-design","title":"\ud83e\udde0 Key Advantages from Internal Design","text":"<ul> <li>Type safety: Leverages Python 3.6+ type hints for automatic request validation.</li> <li>High performance: Asynchronous handling via ASGI/Starlette.</li> <li>Minimal boilerplate: Clean code with auto docs.</li> <li>Extensible: Dependency injection allows for reusable logic and services.</li> </ul>"},{"location":"pydantic/installation/","title":"Installation","text":""},{"location":"pydantic/installation/#installation","title":"Installation","text":"<p>This guide explains how to install Pydantic, a powerful data validation and settings management library for Python.</p>"},{"location":"pydantic/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.7 or higher is required to use Pydantic.</li> <li>It is recommended to use a virtual environment to manage dependencies.</li> </ul>"},{"location":"pydantic/installation/#installing-via-pip","title":"Installing via pip","text":"<p>The easiest way to install Pydantic is using <code>pip</code>:</p> <pre><code>pip install pydantic\n</code></pre> <p>To install a specific version, use:</p> <pre><code>pip install pydantic==1.10.7\n</code></pre> <p>(Replace <code>1.10.7</code> with the desired version number.)</p>"},{"location":"pydantic/installation/#installing-in-a-virtual-environment-recommended","title":"Installing in a Virtual Environment (Recommended)","text":"<ol> <li> <p>Create a virtual environment:</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment:</p> <ul> <li> <p>On Windows:</p> <pre><code>venv\\Scripts\\activate\n</code></pre> </li> <li> <p>On macOS/Linux:</p> <pre><code>source venv/bin/activate\n</code></pre> </li> </ul> </li> <li> <p>Install Pydantic inside the virtual environment:</p> <pre><code>pip install pydantic\n</code></pre> </li> </ol>"},{"location":"pydantic/installation/#verifying-the-installation","title":"Verifying the Installation","text":"<p>After installation, verify that Pydantic is installed correctly by running:</p> <pre><code>python -c \"import pydantic; print(pydantic.VERSION)\"\n</code></pre> <p>You should see the installed version number printed without errors.</p>"},{"location":"pydantic/installation/#installing-from-source","title":"Installing from Source","text":"<p>If you want to install the latest development version, clone the repository and install manually:</p> <pre><code>git clone https://github.com/pydantic/pydantic.git\ncd pydantic\npip install\n</code></pre>"},{"location":"pydantic/installation/#additional-resources","title":"Additional Resources","text":"<ul> <li>Pydantic PyPI page</li> <li>Pydantic GitHub repository</li> </ul> <p>This completes the installation guide for Pydantic. You are now ready to start using Pydantic in your Python projects!</p>"},{"location":"pydantic/introduction/","title":"Introduction","text":""},{"location":"pydantic/introduction/#what-is-pydantic","title":"What is Pydantic?","text":"<p>Pydantic is a powerful data validation and settings management library for Python, based on Python type annotations. It allows you to define data models with clear, concise syntax and automatically validates and parses input data, ensuring that it conforms to the expected types.</p>"},{"location":"pydantic/introduction/#key-features","title":"Key Features","text":"<ul> <li>Data Validation: Automatically validates input data against type annotations.</li> <li>Parsing: Converts input data into Python types, handling complex nested structures.</li> <li>Settings Management: Easily manage application settings with environment variable support.</li> <li>Serialization: Convert models to and from JSON or dictionaries.</li> <li>Performance: Built on top of Python's standard library and optimized for speed.</li> <li>Integration: Works seamlessly with frameworks like FastAPI.</li> </ul>"},{"location":"pydantic/introduction/#basic-example","title":"Basic Example","text":"<p>Here is a simple example demonstrating how to define a Pydantic model and validate data:</p> <pre><code>from pydantic import BaseModel\nfrom typing import Optional, List\n\nclass User(BaseModel):\n    id: int\n    name: str\n    signup_ts: Optional[str] = None\n    friends: List[int] = []\n\n# Creating a user instance with valid data\nuser = User(id=123, name='Alice', friends=[1, 2, 3])\n\nprint(user)\n# Output: id=123 name='Alice' signup_ts=None friends=[1, 2, 3]\n</code></pre>"},{"location":"pydantic/introduction/#how-it-works","title":"How It Works","text":"<ul> <li>You define a class that inherits from <code>BaseModel</code>.</li> <li>Use standard Python type annotations to specify the expected types of fields.</li> <li>When you create an instance, Pydantic validates the input data and converts it to the specified types.</li> <li>If the data is invalid, Pydantic raises detailed validation errors.</li> </ul>"},{"location":"pydantic/introduction/#why-use-pydantic","title":"Why Use Pydantic?","text":"<ul> <li>Reduce Boilerplate: No need to write manual validation code.</li> <li>Increase Reliability: Catch bugs early by enforcing data types.</li> <li>Improve Readability: Clear model definitions that serve as documentation.</li> <li>Enhance Developer Experience: Better autocompletion and type checking in IDEs.</li> </ul>"},{"location":"pydantic/introduction/#further-reading","title":"Further Reading","text":"<ul> <li>Pydantic Documentation</li> <li>Pydantic GitHub Repository</li> <li>FastAPI - Modern, Fast Web Framework</li> </ul> <p>This introduction provides a solid foundation for understanding what Pydantic is and why it is useful in modern Python development.</p>"},{"location":"pydantic/overview/","title":"Overview","text":""},{"location":"pydantic/overview/#pydantic","title":"Pydantic","text":"<p>Pydantic is a data validation library labeled on its website as the most widely used data validation library for Python.</p> <p>It allows you to model your data in a granular way and perform various types of validation while being firmly rooted in the Python type hinting system. The actual version, V2, has critical parts of the code rewritten in Rust for speed and allows for an excellent developer experience.</p> Quote <p>FastAPI is standing on the shoulders of two powerful Python libraries \u2014 Starlette and Pydantic.</p> <p>While Starlette takes care of the web-related aspects of the framework, often through thin wrappers and utility functions and classes provided by FastAPI, Pydantic is responsible for FastAPI\u2019s phenomenal developer experience.</p> <p>Pydantic is fundamental to FastAPI, and leveraging its powerful capabilities opens up the playing field for all FARM stack developers.</p>"},{"location":"pydantic/overview/#pydantic-basics","title":"Pydantic basics","text":"<p>Unlike some other libraries that provide similar functionality (such as <code>dataclasses</code>), Pydantic provides a base model (aptly named <code>BaseModel</code>) that enables the parsing and validation functionality through inheritance.</p> <p>Besides pure data validation, Pydantic provides other important functionalities to your application. Some of the most widely used operations with Pydantic models are the following:</p> <ul> <li>Data deserialization: Ingesting data into the model</li> <li>Data serialization: Outputting validated data from the model into Python data structures or JSON</li> <li>Data modification: Sanitizing or modifying data on the fly</li> </ul>"},{"location":"pydantic/overview/#reference","title":"Reference","text":"<ul> <li>Full Stack FastAPI, React, and MongoDB, Second edition by Marko Aleksendri\u0107, Ph.D.</li> </ul>"},{"location":"pydantic/advanced/complex_types/","title":"Complex Types","text":""},{"location":"pydantic/advanced/complex_types/#complex-types","title":"Complex Types","text":"<p>Pydantic supports a wide range of complex data types out of the box, allowing you to model sophisticated data structures with validation and parsing. This guide covers some of the most commonly used complex types.</p>"},{"location":"pydantic/advanced/complex_types/#1-decimal","title":"1. <code>Decimal</code>","text":"<p>Use <code>decimal.Decimal</code> for precise decimal arithmetic (e.g., financial calculations).</p> <pre><code>from decimal import Decimal\nfrom pydantic import BaseModel\n\nclass Product(BaseModel):\n    price: Decimal\n\nproduct = Product(price='19.99')\nprint(product.price)  # Output: 19.99\nprint(type(product.price))  # Output: &lt;class 'decimal.Decimal'&gt;\n</code></pre>"},{"location":"pydantic/advanced/complex_types/#2-uuid","title":"2. <code>UUID</code>","text":"<p>Use <code>uuid.UUID</code> for universally unique identifiers.</p> <pre><code>from uuid import UUID\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    id: UUID\n\nitem = Item(id='123e4567-e89b-12d3-a456-426614174000')\nprint(item.id)  # Output: 123e4567-e89b-12d3-a456-426614174000\nprint(type(item.id))  # Output: &lt;class 'uuid.UUID'&gt;\n</code></pre>"},{"location":"pydantic/advanced/complex_types/#3-emailstr-and-anyurl","title":"3. <code>EmailStr</code> and <code>AnyUrl</code>","text":"<p>Pydantic provides specialized types for emails and URLs with validation.</p> <pre><code>from pydantic import BaseModel, EmailStr, AnyUrl\n\nclass User(BaseModel):\n    email: EmailStr\n    website: AnyUrl\n\nuser = User(email='user@example.com', website='https://example.com')\nprint(user.email)    # Output: user@example.com\nprint(user.website)  # Output: https://example.com\n</code></pre>"},{"location":"pydantic/advanced/complex_types/#4-path-and-filepath","title":"4. <code>Path</code> and <code>FilePath</code>","text":"<p>Use <code>Path</code> and <code>FilePath</code> from <code>pydantic</code> to validate filesystem paths.</p> <pre><code>from pydantic import BaseModel, FilePath\nfrom pathlib import Path\n\nclass Config(BaseModel):\n    log_file: FilePath\n    data_dir: Path\n\nconfig = Config(log_file='/var/log/app.log', data_dir='/usr/data')\nprint(config.log_file)\nprint(config.data_dir)\n</code></pre>"},{"location":"pydantic/advanced/complex_types/#5-constrained-types","title":"5. <code>Constrained Types</code>","text":"<p>Pydantic supports constrained types like <code>conint</code>, <code>constr</code>, <code>conlist</code> to enforce restrictions.</p> <pre><code>from pydantic import BaseModel, conint, constr\n\nclass User(BaseModel):\n    age: conint(gt=0, lt=120)  # age must be between 1 and 119\n    username: constr(min_length=3, max_length=50)\n\nuser = User(age=30, username='alice')\nprint(user)\n</code></pre>"},{"location":"pydantic/advanced/complex_types/#6-literal","title":"6. <code>Literal</code>","text":"<p>Use <code>Literal</code> to restrict a field to specific literal values.</p> <pre><code>from typing import Literal\nfrom pydantic import BaseModel\n\nclass Pet(BaseModel):\n    type: Literal['cat', 'dog', 'bird']\n\npet = Pet(type='dog')\nprint(pet)\n</code></pre>"},{"location":"pydantic/advanced/complex_types/#7-union-and-optional","title":"7. <code>Union</code> and <code>Optional</code>","text":"<p>Use <code>Union</code> and <code>Optional</code> for fields that can accept multiple types or be nullable.</p> <pre><code>from typing import Union, Optional\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    id: Union[int, str]\n    description: Optional[str]\n\nitem1 = Item(id=123)\nitem2 = Item(id='abc', description='A sample item')\nprint(item1)\nprint(item2)\n</code></pre>"},{"location":"pydantic/advanced/complex_types/#8-tuple","title":"8. <code>Tuple</code>","text":"<p>Use <code>Tuple</code> for fixed-length sequences with specified types.</p> <pre><code>from typing import Tuple\nfrom pydantic import BaseModel\n\nclass Point(BaseModel):\n    coordinates: Tuple[float, float]\n\npoint = Point(coordinates=(10.5, 20.3))\nprint(point)\n</code></pre>"},{"location":"pydantic/advanced/complex_types/#summary","title":"Summary","text":"Type Description <code>Decimal</code> Precise decimal numbers <code>UUID</code> Universally unique identifiers <code>EmailStr</code> Validated email strings <code>AnyUrl</code> Validated URLs <code>Path</code>, <code>FilePath</code> Filesystem path validation <code>conint</code>, <code>constr</code> Constrained integer and string types <code>Literal</code> Restrict to specific literal values <code>Union</code>, <code>Optional</code> Multiple possible types or nullable fields <code>Tuple</code> Fixed-length typed sequences"},{"location":"pydantic/advanced/complex_types/#references","title":"References","text":"<ul> <li>Pydantic Types Documentation</li> <li>Python <code>typing</code> Module</li> </ul> <p>This document introduces complex types supported by Pydantic to help you model and validate sophisticated data structures effectively.</p>"},{"location":"pydantic/advanced/custom_validators/","title":"Custom Validators","text":""},{"location":"pydantic/advanced/custom_validators/#custom-validators","title":"Custom Validators","text":"<p>Pydantic allows you to define custom validation logic for fields using the <code>@validator</code> decorator. This is useful when you need to enforce constraints or transform data beyond basic type checks.</p>"},{"location":"pydantic/advanced/custom_validators/#basic-custom-validator","title":"Basic Custom Validator","text":"<p>Define a validator method decorated with <code>@validator</code> inside your model class. The method receives the field value and should return the validated (or transformed) value or raise a <code>ValueError</code> if validation fails.</p> <pre><code>from pydantic import BaseModel, validator, ValidationError\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n    @validator('name')\n    def name_must_be_capitalized(cls, v):\n        if not v.istitle():\n            raise ValueError('name must be capitalized')\n        return v\n\ntry:\n    user = User(id=1, name='alice')\nexcept ValidationError as e:\n    print(e)\n</code></pre> <ul> <li>The validator checks that the <code>name</code> field is capitalized.</li> <li>If not, it raises a <code>ValueError</code> which Pydantic includes in the validation errors.</li> </ul>"},{"location":"pydantic/advanced/custom_validators/#multiple-validators-for-a-field","title":"Multiple Validators for a Field","text":"<p>You can define multiple validators for the same field by specifying <code>pre=True</code> or <code>each_item=True</code> as needed.</p> <pre><code>from pydantic import BaseModel, validator\n\nclass Item(BaseModel):\n    tags: list[str]\n\n    @validator('tags', pre=True)\n    def split_tags(cls, v):\n        if isinstance(v, str):\n            return [tag.strip() for tag in v.split(',')]\n        return v\n\n    @validator('tags')\n    def tags_must_not_be_empty(cls, v):\n        if not v:\n            raise ValueError('tags must not be empty')\n        return v\n\nitem = Item(tags='red, green, blue')\nprint(item.tags)\n# Output: ['red', 'green', 'blue']\n</code></pre> <ul> <li>The first validator splits a comma-separated string into a list.</li> <li>The second validator ensures the list is not empty.</li> </ul>"},{"location":"pydantic/advanced/custom_validators/#validators-for-multiple-fields","title":"Validators for Multiple Fields","text":"<p>Use <code>@root_validator</code> to validate multiple fields together:</p> <pre><code>from pydantic import BaseModel, root_validator, ValidationError\n\nclass User(BaseModel):\n    password: str\n    password_confirm: str\n\n    @root_validator\n    def passwords_match(cls, values):\n        pw = values.get('password')\n        pw_confirm = values.get('password_confirm')\n        if pw != pw_confirm:\n            raise ValueError('passwords do not match')\n        return values\n\ntry:\n    user = User(password='secret', password_confirm='notsecret')\nexcept ValidationError as e:\n    print(e)\n</code></pre> <ul> <li>This validator ensures that <code>password</code> and <code>password_confirm</code> fields match.</li> </ul>"},{"location":"pydantic/advanced/custom_validators/#validator-parameters","title":"Validator Parameters","text":"<ul> <li><code>pre=True</code>: Run validator before standard validation (useful for data transformation).</li> <li><code>each_item=True</code>: Apply validator to each item in a list or iterable.</li> <li><code>always=True</code>: Run validator even if the field is missing or <code>None</code>.</li> </ul> <p>Example:</p> <pre><code>from pydantic import BaseModel, validator\n\nclass User(BaseModel):\n    name: str = None\n\n    @validator('name', always=True)\n    def set_default_name(cls, v):\n        return v or 'John Doe'\n\nuser = User()\nprint(user.name)  # Output: John Doe\n</code></pre>"},{"location":"pydantic/advanced/custom_validators/#summary","title":"Summary","text":"Validator Type Use Case Decorator Field Validator Validate or transform a single field <code>@validator('field_name')</code> Root Validator Validate multiple fields together <code>@root_validator</code> Pre Validator Transform data before standard validation <code>@validator('field', pre=True)</code> Each Item Validator Validate each item in a list or iterable <code>@validator('field', each_item=True)</code>"},{"location":"pydantic/advanced/custom_validators/#references","title":"References","text":"<ul> <li>Pydantic Validators Documentation</li> <li>Pydantic Root Validators</li> </ul> <p>This document explains how to create custom validators in Pydantic to enforce complex validation logic and data transformations.</p>"},{"location":"pydantic/advanced/generics/","title":"Generic Models","text":""},{"location":"pydantic/advanced/generics/#generic-models","title":"Generic Models","text":"<p>Pydantic supports generic models, allowing you to create reusable, type-safe models that work with different data types. This is especially useful when you want to define structures like containers or wrappers that can hold various types of data.</p>"},{"location":"pydantic/advanced/generics/#defining-a-generic-model","title":"Defining a Generic Model","text":"<p>Use Python\u2019s <code>typing</code> module along with Pydantic\u2019s <code>GenericModel</code> to create generic models.</p> <pre><code>from typing import Generic, TypeVar\nfrom pydantic import BaseModel\nfrom pydantic.generics import GenericModel\n\nT = TypeVar('T')\n\nclass Response(GenericModel, Generic[T]):\n    data: T\n    success: bool\n</code></pre> <ul> <li><code>T</code> is a type variable representing the generic type.</li> <li><code>Response</code> is a generic model that can wrap any type <code>T</code>.</li> </ul>"},{"location":"pydantic/advanced/generics/#using-generic-models","title":"Using Generic Models","text":"<p>You can specify the type parameter when creating instances or subclasses.</p> <pre><code>from pydantic import BaseModel\nfrom pydantic.generics import GenericModel\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Response(GenericModel, Generic[T]):\n    data: T\n    success: bool\n\nclass User(BaseModel):\n    id: int\n    name: str\n\nresponse = Response[User](data=User(id=1, name='Alice'), success=True)\nprint(response)\n# Output: data=User(id=1, name='Alice') success=True\n</code></pre> <ul> <li>Here, <code>Response[User]</code> means the <code>data</code> field expects a <code>User</code> model.</li> </ul>"},{"location":"pydantic/advanced/generics/#generic-models-with-lists","title":"Generic Models with Lists","text":"<p>You can also use generic models with collections like lists.</p> <pre><code>from typing import List\nfrom pydantic.generics import GenericModel\nfrom pydantic import BaseModel\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Response(GenericModel, Generic[T]):\n    data: T\n    success: bool\n\nresponse = Response[List[int]](data=[1, 2, 3], success=True)\nprint(response)\n# Output: data=[1, 2, 3] success=True\n</code></pre> <ul> <li>This example wraps a list of integers inside the generic <code>Response</code> model.</li> </ul>"},{"location":"pydantic/advanced/generics/#subclassing-generic-models","title":"Subclassing Generic Models","text":"<p>You can create subclasses of generic models with concrete types:</p> <pre><code>from typing import TypeVar, Generic\nfrom pydantic import BaseModel\nfrom pydantic.generics import GenericModel\n\nT = TypeVar('T')\n\nclass Response(GenericModel, Generic[T]):\n    data: T\n    success: bool\n\nclass User(BaseModel):\n    id: int\n    name: str\n\nclass UserResponse(Response[User]):\n    pass\n\nuser_response = UserResponse(data=User(id=2, name='Bob'), success=True)\nprint(user_response)\n# Output: data=User(id=2, name='Bob') success=True\n</code></pre> <ul> <li><code>UserResponse</code> is a concrete subclass of <code>Response</code> specialized for <code>User</code>.</li> </ul>"},{"location":"pydantic/advanced/generics/#benefits-of-generic-models","title":"Benefits of Generic Models","text":"<ul> <li>Type Safety: Helps catch type errors early.</li> <li>Reusability: Write once, use with many types.</li> <li>Clear APIs: Explicit about the types models expect.</li> </ul>"},{"location":"pydantic/advanced/generics/#summary","title":"Summary","text":"Feature Description <code>GenericModel</code> Base class for creating generic Pydantic models <code>TypeVar</code> Defines generic type parameters Parameterized Instances Specify concrete types when instantiating or subclassing Supports Collections Use with lists, dicts, and other generics"},{"location":"pydantic/advanced/generics/#references","title":"References","text":"<ul> <li>Pydantic Generics Documentation</li> <li>Python Typing - TypeVar and Generics</li> </ul> <p>This document explains how to define and use generic models in Pydantic for flexible and type-safe data structures.</p>"},{"location":"pydantic/advanced/settings/","title":"Settings Management","text":""},{"location":"pydantic/advanced/settings/#settings-management","title":"Settings Management","text":"<p>Pydantic provides a convenient way to manage application settings and environment variables using the <code>BaseSettings</code> class. This allows you to define configuration models that automatically read from environment variables, <code>.env</code> files, and other sources.</p>"},{"location":"pydantic/advanced/settings/#defining-settings-with-basesettings","title":"Defining Settings with <code>BaseSettings</code>","text":"<p>To create a settings model, inherit from <code>pydantic.BaseSettings</code> instead of <code>BaseModel</code>:</p> <pre><code>from pydantic import BaseSettings\n\nclass Settings(BaseSettings):\n    app_name: str\n    admin_email: str\n    items_per_user: int = 50\n\nsettings = Settings()\nprint(settings.app_name)\nprint(settings.admin_email)\nprint(settings.items_per_user)\n</code></pre> <ul> <li>Fields are defined like in regular Pydantic models.</li> <li>Values are loaded from environment variables by default.</li> <li>You can provide default values as usual.</li> </ul>"},{"location":"pydantic/advanced/settings/#environment-variable-support","title":"Environment Variable Support","text":"<p><code>BaseSettings</code> automatically reads environment variables matching the field names in uppercase:</p> <pre><code>export APP_NAME=\"My Awesome App\"\nexport ADMIN_EMAIL=\"admin@example.com\"\nexport ITEMS_PER_USER=100\n</code></pre> <p>Running the above Python code after setting these environment variables will populate the <code>Settings</code> instance accordingly.</p>"},{"location":"pydantic/advanced/settings/#using-env-files","title":"Using <code>.env</code> Files","text":"<p>You can load settings from a <code>.env</code> file by installing the <code>python-dotenv</code> package and placing a <code>.env</code> file in your project:</p> <pre><code>APP_NAME=My Env App\nADMIN_EMAIL=envadmin@example.com\nITEMS_PER_USER=25\n</code></pre> <p><code>BaseSettings</code> will automatically read from the <code>.env</code> file if present.</p>"},{"location":"pydantic/advanced/settings/#customizing-environment-variable-names","title":"Customizing Environment Variable Names","text":"<p>You can customize the environment variable names using <code>Field</code> with the <code>env</code> parameter:</p> <pre><code>from pydantic import BaseSettings, Field\n\nclass Settings(BaseSettings):\n    app_name: str = Field(..., env='MY_APP_NAME')\n    admin_email: str = Field(..., env='MY_ADMIN_EMAIL')\n</code></pre> <p>Now, <code>MY_APP_NAME</code> and <code>MY_ADMIN_EMAIL</code> environment variables will be used instead.</p>"},{"location":"pydantic/advanced/settings/#nested-settings","title":"Nested Settings","text":"<p>You can nest settings models for better organization:</p> <pre><code>from pydantic import BaseSettings\n\nclass DatabaseSettings(BaseSettings):\n    host: str\n    port: int\n\nclass Settings(BaseSettings):\n    app_name: str\n    database: DatabaseSettings\n\nsettings = Settings()\nprint(settings.database.host)\n</code></pre> <p>Environment variables for nested models use <code>__</code> (double underscore) as a separator by default:</p> <pre><code>export DATABASE__HOST=localhost\nexport DATABASE__PORT=5432\n</code></pre>"},{"location":"pydantic/advanced/settings/#secrets-management","title":"Secrets Management","text":"<p>You can use Pydantic\u2019s <code>SecretStr</code> and <code>SecretBytes</code> types to handle sensitive data securely:</p> <pre><code>from pydantic import BaseSettings, SecretStr\n\nclass Settings(BaseSettings):\n    db_password: SecretStr\n\nsettings = Settings()\nprint(settings.db_password)  # Will not print the secret value\nprint(settings.db_password.get_secret_value())  # To access the actual secret\n</code></pre>"},{"location":"pydantic/advanced/settings/#example-complete-settings-model","title":"Example: Complete Settings Model","text":"<pre><code>from pydantic import BaseSettings, SecretStr, Field\n\nclass Settings(BaseSettings):\n    app_name: str = Field(..., env='APP_NAME')\n    admin_email: str = Field(..., env='ADMIN_EMAIL')\n    items_per_user: int = 50\n    db_password: SecretStr\n\nsettings = Settings()\nprint(settings.app_name)\nprint(settings.admin_email)\nprint(settings.items_per_user)\nprint(settings.db_password.get_secret_value())\n</code></pre>"},{"location":"pydantic/advanced/settings/#summary","title":"Summary","text":"Feature Description <code>BaseSettings</code> Base class for settings with env var support Environment Variables Automatically read from env vars <code>.env</code> File Support Load settings from <code>.env</code> files Custom Env Variable Names Use <code>Field(..., env='VAR_NAME')</code> Nested Settings Support for nested configuration models Secrets Management Use <code>SecretStr</code> and <code>SecretBytes</code> for secrets"},{"location":"pydantic/advanced/settings/#references","title":"References","text":"<ul> <li>Pydantic Settings Documentation</li> <li>python-dotenv</li> </ul> <p>This document explains how to manage application settings effectively using Pydantic\u2019s <code>BaseSettings</code> for environment variable parsing, <code>.env</code> support, secrets handling, and nested configurations.</p>"},{"location":"pydantic/concepts/fields_and_types/","title":"Fields and Types","text":""},{"location":"pydantic/concepts/fields_and_types/#fields-and-types","title":"Fields and Types","text":"<p>Pydantic models use Python type annotations to define fields and their expected types. This allows Pydantic to perform validation and parsing automatically.</p>"},{"location":"pydantic/concepts/fields_and_types/#basic-field-types","title":"Basic Field Types","text":"<p>You can use standard Python types as field annotations:</p> <pre><code>from pydantic import BaseModel\n\nclass Product(BaseModel):\n    id: int\n    name: str\n    price: float\n    in_stock: bool\n</code></pre> <ul> <li><code>id</code> is an integer.</li> <li><code>name</code> is a string.</li> <li><code>price</code> is a floating-point number.</li> <li><code>in_stock</code> is a boolean.</li> </ul>"},{"location":"pydantic/concepts/fields_and_types/#optional-fields","title":"Optional Fields","text":"<p>To specify that a field is optional (can be <code>None</code>), use <code>Optional</code> from the <code>typing</code> module:</p> <pre><code>from typing import Optional\nfrom pydantic import BaseModel\n\nclass Product(BaseModel):\n    id: int\n    name: str\n    description: Optional[str] = None\n</code></pre> <ul> <li><code>description</code> can be a string or <code>None</code>.</li> <li>The default value <code>None</code> makes the field optional.</li> </ul>"},{"location":"pydantic/concepts/fields_and_types/#default-values","title":"Default Values","text":"<p>You can provide default values for fields:</p> <pre><code>from pydantic import BaseModel\n\nclass Product(BaseModel):\n    id: int\n    name: str\n    price: float = 0.0\n    in_stock: bool = True\n</code></pre> <ul> <li>If <code>price</code> or <code>in_stock</code> are not provided, they default to <code>0.0</code> and <code>True</code>, respectively.</li> </ul>"},{"location":"pydantic/concepts/fields_and_types/#complex-types","title":"Complex Types","text":"<p>Pydantic supports complex types such as lists, dictionaries, tuples, and nested models:</p> <pre><code>from typing import List, Dict, Tuple\nfrom pydantic import BaseModel\n\nclass Order(BaseModel):\n    order_id: int\n    product_ids: List[int]\n    metadata: Dict[str, str]\n    coordinates: Tuple[float, float]\n</code></pre> <ul> <li><code>product_ids</code> is a list of integers.</li> <li><code>metadata</code> is a dictionary with string keys and values.</li> <li><code>coordinates</code> is a tuple of two floats.</li> </ul>"},{"location":"pydantic/concepts/fields_and_types/#nested-models","title":"Nested Models","text":"<p>You can nest Pydantic models inside other models:</p> <pre><code>from pydantic import BaseModel\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    zip_code: str\n\nclass User(BaseModel):\n    id: int\n    name: str\n    address: Address\n</code></pre> <ul> <li>The <code>address</code> field is itself a Pydantic model.</li> </ul>"},{"location":"pydantic/concepts/fields_and_types/#field-validation-with-field","title":"Field Validation with <code>Field</code>","text":"<p>Use <code>Field</code> to provide additional metadata and validation constraints:</p> <pre><code>from pydantic import BaseModel, Field\n\nclass Product(BaseModel):\n    id: int = Field(..., gt=0, description=\"The product ID must be greater than zero\")\n    name: str = Field(..., max_length=100)\n    price: float = Field(0.0, ge=0.0)\n</code></pre> <ul> <li><code>gt=0</code>: value must be greater than 0.</li> <li><code>ge=0.0</code>: value must be greater than or equal to 0.0.</li> <li><code>max_length=100</code>: string length must not exceed 100 characters.</li> <li><code>...</code> means the field is required.</li> </ul>"},{"location":"pydantic/concepts/fields_and_types/#summary","title":"Summary","text":"Feature Description Type Annotations Define expected types for fields Optional Fields Use <code>Optional</code> and default <code>None</code> Default Values Provide default values for fields Complex Types Support for lists, dicts, tuples, nested models Field Validation Use <code>Field</code> for constraints and metadata"},{"location":"pydantic/concepts/fields_and_types/#references","title":"References","text":"<ul> <li>Pydantic Fields Documentation</li> <li>Python Typing Module</li> </ul> <p>This document explains how to define fields and types in Pydantic models to leverage automatic validation and parsing.</p>"},{"location":"pydantic/concepts/models/","title":"Models","text":""},{"location":"pydantic/concepts/models/#models","title":"Models","text":"<p>Pydantic models are the core feature of the library. They provide a way to define data structures with type annotations, automatic validation, and parsing.</p>"},{"location":"pydantic/concepts/models/#defining-a-model","title":"Defining a Model","text":"<p>To define a Pydantic model, create a class that inherits from <code>BaseModel</code> and declare attributes with type annotations.</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    is_active: bool = True\n</code></pre> <ul> <li><code>id</code> and <code>name</code> are required fields.</li> <li><code>is_active</code> has a default value of <code>True</code>.</li> </ul>"},{"location":"pydantic/concepts/models/#creating-model-instances","title":"Creating Model Instances","text":"<p>You can create instances of the model by passing data as keyword arguments:</p> <pre><code>user = User(id=1, name='Alice')\nprint(user)\n# Output: id=1 name='Alice' is_active=True\n</code></pre> <p>Pydantic will validate the data types and apply default values where necessary.</p>"},{"location":"pydantic/concepts/models/#data-validation-and-parsing","title":"Data Validation and Parsing","text":"<p>Pydantic automatically validates input data and converts types when possible:</p> <pre><code>user = User(id='123', name='Bob', is_active='false')\nprint(user)\n# Output: id=123 name='Bob' is_active=False\n</code></pre> <ul> <li>The string <code>'123'</code> is parsed as integer <code>123</code>.</li> <li>The string <code>'false'</code> is parsed as boolean <code>False</code>.</li> </ul> <p>If validation fails, Pydantic raises a <code>ValidationError</code>:</p> <pre><code>from pydantic import ValidationError\n\ntry:\n    user = User(id='abc', name=123)\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"pydantic/concepts/models/#accessing-model-data","title":"Accessing Model Data","text":"<p>You can access model attributes like regular Python objects:</p> <pre><code>print(user.name) # Output: Bob\n</code></pre> <p>To get a dictionary representation of the model:</p> <pre><code>print(user.dict())\n# Output: {'id': 123, 'name': 'Bob', 'is_active': False}\n</code></pre>"},{"location":"pydantic/concepts/models/#model-configurations","title":"Model Configurations","text":"<p>You can customize model behavior by defining an inner <code>Config</code> class:</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n    class Config:\n        orm_mode = True\n</code></pre> <ul> <li><code>orm_mode = True</code> allows models to be created from ORM objects.</li> </ul>"},{"location":"pydantic/concepts/models/#summary","title":"Summary","text":"Feature Description Inherit from <code>BaseModel</code> Define your data model Type Annotations Specify field types Default Values Provide defaults for optional fields Automatic Validation Validate and parse input data Error Handling Raise <code>ValidationError</code> on invalid data Model Configuration Customize behavior with <code>Config</code> class"},{"location":"pydantic/concepts/models/#references","title":"References","text":"<ul> <li>Pydantic Models Documentation</li> <li>Pydantic GitHub Repository</li> </ul> <p>This document provides a comprehensive overview of Pydantic models, enabling you to define and use validated data structures effectively.</p>"},{"location":"pydantic/concepts/serialization/","title":"Serialization and Parsing","text":""},{"location":"pydantic/concepts/serialization/#serialization-and-parsing","title":"Serialization and Parsing","text":"<p>Pydantic models provide easy and efficient ways to serialize data to various formats and parse data from different sources. This section covers how to serialize models to JSON and dictionaries, and how to parse data into models.</p>"},{"location":"pydantic/concepts/serialization/#serializing-to-dictionary","title":"Serializing to Dictionary","text":"<p>You can convert a Pydantic model instance to a Python dictionary using the <code>.dict()</code> method:</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    is_active: bool = True\n\nuser = User(id=1, name='Alice')\nprint(user.dict())\n# Output: {'id': 1, 'name': 'Alice', 'is_active': True}\n</code></pre> <ul> <li>The <code>.dict()</code> method returns a standard Python dictionary representing the model data.</li> <li>You can customize <code>.dict()</code> with options like <code>exclude</code>, <code>include</code>, and <code>by_alias</code>.</li> </ul>"},{"location":"pydantic/concepts/serialization/#serializing-to-json","title":"Serializing to JSON","text":"<p>To serialize a model to a JSON string, use the <code>.json()</code> method:</p> <pre><code>print(user.json())\n# Output: '{\"id\": 1, \"name\": \"Alice\", \"is_active\": true}'\n</code></pre> <ul> <li>The <code>.json()</code> method returns a JSON-formatted string.</li> <li>Supports options like <code>exclude</code>, <code>include</code>, <code>by_alias</code>, and <code>indent</code> for pretty-printing.</li> </ul>"},{"location":"pydantic/concepts/serialization/#parsing-data-into-models","title":"Parsing Data into Models","text":"<p>Pydantic models can parse data from dictionaries or JSON strings.</p>"},{"location":"pydantic/concepts/serialization/#parsing-from-dictionary","title":"Parsing from Dictionary","text":"<pre><code>data = {'id': 2, 'name': 'Bob', 'is_active': False}\nuser = User.parse_obj(data)\nprint(user)\n# Output: id=2 name='Bob' is_active=False\n</code></pre> <ul> <li><code>parse_obj</code> takes a dictionary (or any mapping) and returns a model instance.</li> </ul>"},{"location":"pydantic/concepts/serialization/#parsing-from-json-string","title":"Parsing from JSON String","text":"<pre><code>json_data = '{\"id\": 3, \"name\": \"Charlie\", \"is_active\": true}'\nuser = User.parse_raw(json_data)\nprint(user)\n# Output: id=3 name='Charlie' is_active=True\n</code></pre> <ul> <li><code>parse_raw</code> parses JSON (or other supported formats) strings into model instances.</li> </ul>"},{"location":"pydantic/concepts/serialization/#parsing-from-other-formats","title":"Parsing from Other Formats","text":"<p><code>parse_raw</code> can also parse data from other formats such as bytes or JSON bytes.</p> <pre><code>json_bytes = b'{\"id\": 4, \"name\": \"Diana\", \"is_active\": false}'\nuser = User.parse_raw(json_bytes)\nprint(user)\n# Output: id=4 name='Diana' is_active=False\n</code></pre>"},{"location":"pydantic/concepts/serialization/#custom-serialization","title":"Custom Serialization","text":"<p>You can customize how fields are serialized using the <code>Config</code> class:</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n    class Config:\n        json_encoders = {\n            # Example: serialize datetime fields as ISO format strings\n            # datetime: lambda v: v.isoformat()\n        }\n</code></pre>"},{"location":"pydantic/concepts/serialization/#summary","title":"Summary","text":"Method Description <code>.dict()</code> Serialize model to Python dictionary <code>.json()</code> Serialize model to JSON string <code>parse_obj()</code> Parse data from dictionary or mapping <code>parse_raw()</code> Parse data from JSON string or bytes"},{"location":"pydantic/concepts/serialization/#references","title":"References","text":"<ul> <li>Pydantic Serialization Documentation</li> <li>Pydantic Parsing Documentation</li> </ul> <p>This document explains how to serialize Pydantic models to dictionaries and JSON, and how to parse data into models efficiently.</p>"},{"location":"pydantic/concepts/validation/","title":"Validation","text":""},{"location":"pydantic/concepts/validation/#validation","title":"Validation","text":"<p>Pydantic provides powerful validation capabilities that ensure the data conforms to the expected types and constraints. Validation happens automatically when creating model instances.</p>"},{"location":"pydantic/concepts/validation/#basic-validation","title":"Basic Validation","text":"<p>When you create a Pydantic model instance, it validates the input data against the declared types:</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n# Valid input\nuser = User(id=123, name='Alice')\nprint(user)\n\n# Invalid input raises ValidationError\ntry:\n    user = User(id='abc', name=123)\nexcept Exception as e:\n    print(e)\n</code></pre> <ul> <li>The first instance is valid and prints the user.</li> <li>The second instance raises a <code>ValidationError</code> because <code>id</code> should be an integer and <code>name</code> should be a string.</li> </ul>"},{"location":"pydantic/concepts/validation/#validationerror","title":"ValidationError","text":"<p>When validation fails, Pydantic raises a <code>ValidationError</code> that contains detailed information about all errors:</p> <pre><code>from pydantic import ValidationError\n\ntry:\n    user = User(id='abc', name=123)\nexcept ValidationError as e:\n    print(e.json())\n</code></pre> <p>The error output includes the location, error type, and message for each invalid field.</p>"},{"location":"pydantic/concepts/validation/#custom-validators","title":"Custom Validators","text":"<p>You can define custom validation logic using the <code>@validator</code> decorator:</p> <pre><code>from pydantic import BaseModel, validator, ValidationError\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n    @validator('name')\n    def name_must_be_capitalized(cls, v):\n        if not v.istitle():\n            raise ValueError('name must be capitalized')\n        return v\n\ntry:\n    user = User(id=1, name='alice')\nexcept ValidationError as e:\n    print(e)\n</code></pre> <ul> <li>The validator checks that the <code>name</code> field is capitalized.</li> <li>If not, it raises a <code>ValueError</code> which Pydantic includes in the validation errors.</li> </ul>"},{"location":"pydantic/concepts/validation/#field-constraints","title":"Field Constraints","text":"<p>Pydantic provides built-in field constraints using <code>Field</code>:</p> <pre><code>from pydantic import BaseModel, Field\n\nclass Product(BaseModel):\n    id: int = Field(..., gt=0)\n    price: float = Field(..., ge=0.0)\n</code></pre> <ul> <li><code>gt=0</code> means the value must be greater than 0.</li> <li><code>ge=0.0</code> means the value must be greater than or equal to 0.0.</li> </ul>"},{"location":"pydantic/concepts/validation/#root-validators","title":"Root Validators","text":"<p>For validation that depends on multiple fields, use <code>@root_validator</code>:</p> <pre><code>from pydantic import BaseModel, root_validator, ValidationError\n\nclass User(BaseModel):\n    password: str\n    password_confirm: str\n\n    @root_validator\n    def passwords_match(cls, values):\n        pw = values.get('password')\n        pw_confirm = values.get('password_confirm')\n        if pw != pw_confirm:\n            raise ValueError('passwords do not match')\n        return values\n\ntry:\n    user = User(password='secret', password_confirm='notsecret')\nexcept ValidationError as e:\n    print(e)\n</code></pre> <ul> <li>This validator ensures the two password fields match.</li> </ul>"},{"location":"pydantic/concepts/validation/#summary","title":"Summary","text":"Feature Description Automatic Validation Validates data on model instantiation ValidationError Detailed error reporting for invalid data Custom Validators Define field-specific validation logic Field Constraints Use <code>Field</code> to enforce value restrictions Root Validators Validate multiple fields together"},{"location":"pydantic/concepts/validation/#references","title":"References","text":"<ul> <li>Pydantic Validation Documentation</li> <li>Pydantic Error Handling</li> </ul> <p>This document explains how Pydantic validates data and how to customize validation logic for robust data models.</p>"},{"location":"pydantic/error-handling/custom_errors/","title":"Custom Error Messages","text":""},{"location":"pydantic/error-handling/custom_errors/#custom-error-messages","title":"Custom Error Messages","text":"<p>Pydantic allows you to customize error messages for validation failures, giving you control over how validation errors are reported. This document explains how to define custom error messages using validators and constrained types.</p>"},{"location":"pydantic/error-handling/custom_errors/#1-using-validators-with-custom-errors","title":"1. Using Validators with Custom Errors","text":"<p>You can raise <code>ValueError</code> or <code>TypeError</code> with custom messages inside validators to provide specific error feedback.</p> <pre><code>from pydantic import BaseModel, ValidationError, field_validator\n\nclass User(BaseModel):\n    username: str\n\n    @field_validator('username')\n    @classmethod\n    def username_must_be_alphanumeric(cls, v):\n        if not v.isalnum():\n            raise ValueError('Username must be alphanumeric')\n        return v\n\ntry:\n    User(username='invalid username!')\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>Output:</p> <pre><code>1 validation error for User\nusername\nUsername must be alphanumeric (type=value_error)\n</code></pre>"},{"location":"pydantic/error-handling/custom_errors/#2-using-constr-with-custom-error-messages","title":"2. Using <code>constr</code> with Custom Error Messages","text":"<p>When using constrained types like <code>constr</code>, you can specify custom error messages by subclassing and overriding <code>__get_validators__</code>.</p> <pre><code>from pydantic import BaseModel, ValidationError\n\nclass CustomStr(str):\n    @classmethod\n    def __get_validators__(cls):\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, v):\n        if not isinstance(v, str):\n            raise TypeError('string required')\n        if len(v) &lt; 5:\n            raise ValueError('string too short, minimum length is 5')\n        return v\n\nclass User(BaseModel):\n    username: CustomStr\n\ntry:\n    User(username='abc')\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>Output:</p> <pre><code>1 validation error for User\nusername\nstring too short, minimum length is 5 (type=value_error)\n</code></pre>"},{"location":"pydantic/error-handling/custom_errors/#3-using-validator-with-alwaystrue-and-custom-messages","title":"3. Using <code>@validator</code> with <code>always=True</code> and Custom Messages","text":"<p>You can use the <code>@validator</code> decorator with <code>always=True</code> to enforce validation even if the field is missing, and raise custom errors.</p> <pre><code>from pydantic import BaseModel, ValidationError, validator\n\nclass User(BaseModel):\n    email: str\n\n    @validator('email', always=True)\n    def email_must_contain_at_symbol(cls, v):\n        if '@' not in v:\n            raise ValueError('Email must contain \"@\" symbol')\n        return v\n\ntry:\n    User(email='invalidemail.com')\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>Output:</p> <pre><code>1 validation error for User\nemail\nEmail must contain \"@\" symbol (type=value_error)\n</code></pre>"},{"location":"pydantic/error-handling/custom_errors/#4-raising-custom-exceptions-in-validators","title":"4. Raising Custom Exceptions in Validators","text":"<p>You can define custom exception classes and raise them inside validators to provide more structured error handling.</p> <pre><code>from pydantic import BaseModel, ValidationError, field_validator\n\nclass UsernameError(ValueError):\n    pass\n\nclass User(BaseModel):\n    username: str\n\n    @field_validator('username')\n    @classmethod\n    def check_username(cls, v):\n        if not v.isalnum():\n            raise UsernameError('Username must be alphanumeric')\n        return v\n\ntry:\n    User(username='invalid username!')\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>Output:</p> <pre><code>1 validation error for User\nusername\nUsername must be alphanumeric (type=value_error)\n</code></pre>"},{"location":"pydantic/error-handling/custom_errors/#5-customizing-error-messages-for-constrained-types","title":"5. Customizing Error Messages for Constrained Types","text":"<p>You can customize error messages for constrained types like <code>conint</code>, <code>constr</code>, etc., by subclassing them.</p> <pre><code>from pydantic import BaseModel, conint, ValidationError\n\nclass PositiveInt(conint(gt=0)):\n    @classmethod\n    def __get_validators__(cls):\n        yield from super().__get_validators__()\n        yield cls.custom_error\n\n    @classmethod\n    def custom_error(cls, v):\n        if v &lt;= 0:\n            raise ValueError('Value must be a positive integer')\n        return v\n\nclass User(BaseModel):\n    age: PositiveInt\n\ntry:\n    User(age=-5)\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>Output:</p> <pre><code>1 validation error for User\nage\nValue must be a positive integer (type=value_error)\n</code></pre>"},{"location":"pydantic/error-handling/custom_errors/#summary","title":"Summary","text":"Method Description Validators with <code>ValueError</code> Raise <code>ValueError</code> with custom messages inside validators. Custom Types with Validators Define custom types and validators with tailored messages. <code>@validator(always=True)</code> Enforce validation even if field is missing, with custom errors. Custom Exception Classes Raise custom exceptions inside validators for structured errors. Subclassing Constrained Types Customize error messages by subclassing constrained types."},{"location":"pydantic/error-handling/custom_errors/#references","title":"References","text":"<ul> <li>Pydantic Validators</li> <li>Pydantic Custom Data Types</li> <li>Pydantic Error Handling</li> </ul> <p>This document explains how to customize error messages in Pydantic models to provide clearer, user-friendly validation feedback.</p>"},{"location":"pydantic/error-handling/validation_errors/","title":"Validation Errors","text":""},{"location":"pydantic/error-handling/validation_errors/#validation-errors","title":"Validation Errors","text":"<p>Pydantic provides detailed and helpful validation errors to help you identify and fix issues in your data models. This document covers common validation errors, how they occur, and examples of their usage.</p>"},{"location":"pydantic/error-handling/validation_errors/#overview","title":"Overview","text":"<ul> <li>Pydantic raises a <code>ValidationError</code> whenever it encounters invalid data during model validation.</li> <li>Validation errors contain detailed information about what failed, where, and why.</li> <li>You should raise <code>ValueError</code>, <code>AssertionError</code>, or <code>PydanticCustomError</code> in validators to indicate validation failures; do not raise <code>ValidationError</code> directly.</li> <li> <p>Use the <code>ValidationError</code> methods to inspect errors:</p> <ul> <li><code>errors()</code> - returns a list of error details.</li> <li><code>error_count()</code> - returns the number of errors.</li> <li><code>json()</code> - returns a JSON representation of the errors.</li> <li><code>str(e)</code> - human-readable error message.</li> </ul> </li> </ul>"},{"location":"pydantic/error-handling/validation_errors/#common-validation-error-types","title":"Common Validation Error Types","text":""},{"location":"pydantic/error-handling/validation_errors/#1-arguments_type","title":"1. <code>arguments_type</code>","text":"<p>Raised when the input to a function expecting a tuple, list, or dict is of an invalid type.</p> <pre><code>from typing import NamedTuple\nfrom pydantic import BaseModel, ValidationError\n\nclass MyNamedTuple(NamedTuple):\n    x: int\n\nclass MyModel(BaseModel):\n    field: MyNamedTuple\n\ntry:\n    MyModel.model_validate({'field': 'invalid'})\nexcept ValidationError as exc:\n    # Access the first error's 'type'\n    print(exc.errors()[0]['type'])\n# Output: 'arguments_type'\n</code></pre>"},{"location":"pydantic/error-handling/validation_errors/#2-assertion_error","title":"2. <code>assertion_error</code>","text":"<p>Raised when an <code>assert</code> statement fails inside a validator.</p> <pre><code>from pydantic import BaseModel, ValidationError, field_validator\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    @classmethod\n    def force_x_positive(cls, v):\n        assert v &gt; 0\n        return v\n\ntry:\n    Model(x=-1)\nexcept ValidationError as exc:\n    print(exc.errors()[0]['type'])\n# Output: 'assertion_error'\n</code></pre>"},{"location":"pydantic/error-handling/validation_errors/#3-literal_error","title":"3. <code>literal_error</code>","text":"<p>Raised when a value is not one of the expected literals.</p> <pre><code>from typing import Literal\nfrom pydantic import BaseModel, ValidationError\n\nclass Model(BaseModel):\n    x: Literal['a', 'b']\n\nModel(x='a')  # OK\n\ntry:\n    Model(x='c')\nexcept ValidationError as exc:\n    print(exc.errors()[0]['type'])\n# Output: 'literal_error'\n</code></pre>"},{"location":"pydantic/error-handling/validation_errors/#4-mapping_type","title":"4. <code>mapping_type</code>","text":"<p>Raised when an error occurs during validation related to the <code>Mapping</code> protocol methods.</p> <pre><code>from collections.abc import Mapping\nfrom pydantic import BaseModel, ValidationError\n\nclass BadMapping(Mapping):\n    def items(self):\n        raise ValueError()\n\n    def __iter__(self):\n        raise ValueError()\n\n    def __getitem__(self, key):\n        raise ValueError()\n\n    def __len__(self):\n        return 1\n\nclass Model(BaseModel):\n    x: dict[str, str]\n\ntry:\n    Model(x=BadMapping())\nexcept ValidationError as exc:\n    print(exc.errors()[0]['type'])\n# Output: 'mapping_type'\n</code></pre>"},{"location":"pydantic/error-handling/validation_errors/#5-missing","title":"5. <code>missing</code>","text":"<p>Raised when required fields are missing from the input.</p>"},{"location":"pydantic/error-handling/validation_errors/#6-model_type","title":"6. <code>model_type</code>","text":"<p>Raised when the input to a model is not a valid instance or dict.</p> <pre><code>from pydantic import BaseModel, ValidationError\n\nclass Model(BaseModel):\n    a: int\n    b: int\n\nm = Model.model_validate({'a': 1, 'b': 2})\nprint(m)\n\nprint(Model.model_validate(m))\n\ntry:\n    Model.model_validate('not an object')\nexcept ValidationError as exc:\n    print(exc.errors()[0]['type'])\n# Output: 'model_type'\n</code></pre>"},{"location":"pydantic/error-handling/validation_errors/#7-multiple_argument_values","title":"7. <code>multiple_argument_values</code>","text":"<p>Raised when multiple values are provided for a single argument in a function decorated with <code>validate_call</code>.</p> <pre><code>from pydantic import ValidationError, validate_call\n\n@validate_call\ndef foo(a: int):\n    return a\n\ntry:\n    foo(1, a=2)\nexcept ValidationError as exc:\n    print(exc.errors()[0]['type'])\n# Output: 'multiple_argument_values'\n</code></pre>"},{"location":"pydantic/error-handling/validation_errors/#8-multiple_of","title":"8. <code>multiple_of</code>","text":"<p>Raised when a value does not satisfy a <code>multiple_of</code> constraint.</p>"},{"location":"pydantic/error-handling/validation_errors/#example-of-complex-validation-errors","title":"Example of Complex Validation Errors","text":"<pre><code>from pydantic import BaseModel, Field, ValidationError, field_validator\n\nclass Location(BaseModel):\n    lat: float = 0.1\n    lng: float = 10.1\n\nclass Model(BaseModel):\n    is_required: float\n    gt_int: int = Field(gt=42)\n    list_of_ints: list[int]\n    a_float: float\n    recursive_model: Location\n\n    @field_validator('a_float', mode='after')\n    @classmethod\n    def validate_float(cls, value: float) -&gt; float:\n        if value &gt; 2.0:\n            raise ValueError('Invalid float value')\n        return value\n\ndata = {\n    'list_of_ints': ['1', 2, 'bad'],\n    'a_float': 3.0,\n    'recursive_model': {'lat': 4.2, 'lng': 'New York'},\n    'gt_int': 21,\n}\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e)\n</code></pre> <pre><code>5 validation errors for Model\nis_required\n  Field required [type=missing, input_value={'list_of_ints': ['1', 2, 'bad'], 'a_float': 3.0, 'recursive_model': {'lat': 4.2, 'lng': 'New York'}, 'gt_int': 21}, input_type=dict]\ngt_int\n  Input should be greater than 42 [type=greater_than, input_value=21, input_type=int]\nlist_of_ints.2\n  Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='bad', input_type=str]\na_float\n  Value error, Invalid float value [type=value_error, input_value=3.0, input_type=float]\nrecursive_model.lng\n  Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='New York', input_type=str]\n</code></pre>"},{"location":"pydantic/error-handling/validation_errors/#accessing-error-details-programmatically","title":"Accessing Error Details Programmatically","text":"<pre><code>try:\n    Model(**data)\nexcept ValidationError as e:\n    errors = e.errors()\n    for err in errors:\n        print(f\"Error type: {err['type']}\")\n        print(f\"Location: {err['loc']}\")\n        print(f\"Message: {err['msg']}\")\n        print(f\"Input: {err.get('input')}\")\n        print(f\"Context: {err.get('ctx')}\")\n        print(f\"Documentation: {err.get('url')}\")\n        print()\n</code></pre>"},{"location":"pydantic/error-handling/validation_errors/#summary","title":"Summary","text":"Error Type Description <code>arguments_type</code> Invalid argument type passed to function <code>assertion_error</code> Assertion failed in validator <code>literal_error</code> Value not in expected literals <code>mapping_type</code> Error during mapping protocol call <code>missing</code> Required field missing <code>model_type</code> Input not a valid model or dict <code>multiple_argument_values</code> Multiple values for one argument in function <code>multiple_of</code> Value not multiple of specified number"},{"location":"pydantic/error-handling/validation_errors/#references","title":"References","text":"<ul> <li>Pydantic Validation Errors Documentation</li> <li>Pydantic Error Handling</li> <li>Pydantic Validators</li> </ul> <p>This document explains common validation errors in Pydantic, how to interpret them, and how to handle them effectively.</p>"},{"location":"pydantic/integration/fastapi_integration/","title":"FastAPI Integration","text":""},{"location":"pydantic/integration/fastapi_integration/#fastapi-integration","title":"FastAPI Integration","text":"<p>Pydantic is tightly integrated with FastAPI, providing automatic data validation, serialization, and documentation generation. This document explains how to use Pydantic models effectively within FastAPI applications.</p>"},{"location":"pydantic/integration/fastapi_integration/#1-defining-request-and-response-models","title":"1. Defining Request and Response Models","text":"<p>Use Pydantic models to define the shape of request bodies and response data.</p> <pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    id: int\n    name: str\n    price: float\n    tags: list[str] = []\n\n@app.post(\"/items/\", response_model=Item)\nasync def create_item(item: Item):\n    return item\n</code></pre> <ul> <li>The <code>Item</code> model defines the expected request body and response schema.</li> <li>FastAPI automatically validates incoming JSON against the <code>Item</code> model.</li> <li>The response is serialized using the same model.</li> </ul>"},{"location":"pydantic/integration/fastapi_integration/#2-query-parameters-and-path-parameters-validation","title":"2. Query Parameters and Path Parameters Validation","text":"<p>Pydantic types can be used to validate query and path parameters.</p> <pre><code>from fastapi import FastAPI, Query\n\napp = FastAPI()\n\n@app.get(\"/items/\")\nasync def read_items(q: str = Query(..., min_length=3, max_length=50)):\n    return {\"q\": q}\n</code></pre> <ul> <li>The query parameter <code>q</code> is validated to be a string with length between 3 and 50.</li> <li>FastAPI uses Pydantic's validation under the hood.</li> </ul>"},{"location":"pydantic/integration/fastapi_integration/#3-using-pydantic-field-for-metadata-and-validation","title":"3. Using Pydantic <code>Field</code> for Metadata and Validation","text":"<p>You can use <code>Field</code> to add metadata, default values, and validation constraints.</p> <pre><code>from pydantic import BaseModel, Field\n\nclass User(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50, description=\"The user's username\")\n    age: int = Field(..., gt=0, lt=130, description=\"The user's age\")\n</code></pre> <ul> <li>The <code>Field</code> function adds validation and metadata used in OpenAPI docs.</li> <li>FastAPI generates interactive API docs with these descriptions.</li> </ul>"},{"location":"pydantic/integration/fastapi_integration/#4-nested-models","title":"4. Nested Models","text":"<p>Pydantic supports nested models for complex data structures.</p> <pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    country: str\n\nclass User(BaseModel):\n    name: str\n    address: Address\n\n@app.post(\"/users/\")\nasync def create_user(user: User):\n    return user\n</code></pre> <ul> <li>Nested models allow validation of complex JSON payloads.</li> <li>All nested fields are validated recursively.</li> </ul>"},{"location":"pydantic/integration/fastapi_integration/#5-response-model-customization","title":"5. Response Model Customization","text":"<p>You can control which fields are included or excluded in response models.</p> <pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n@app.get(\"/users/{user_id}\", response_model=User, response_model_exclude={\"password\"})\nasync def get_user(user_id: int):\n    user = {\"username\": \"alice\", \"password\": \"secret\"}\n    return user\n</code></pre> <ul> <li>The <code>password</code> field is excluded from the response.</li> <li>This helps avoid exposing sensitive data.</li> </ul>"},{"location":"pydantic/integration/fastapi_integration/#6-using-union-and-optional-in-fastapi","title":"6. Using <code>Union</code> and <code>Optional</code> in FastAPI","text":"<p>Pydantic supports <code>Union</code> and <code>Optional</code> for flexible field types.</p> <pre><code>from typing import Union, Optional\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    id: Union[int, str]\n    description: Optional[str] = None\n\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n    return item\n</code></pre> <ul> <li><code>id</code> can be either an integer or a string.</li> <li><code>description</code> is optional.</li> </ul>"},{"location":"pydantic/integration/fastapi_integration/#7-validation-errors-handling","title":"7. Validation Errors Handling","text":"<p>FastAPI automatically returns validation errors as JSON responses with HTTP status 422.</p> <p>Example error response:</p> <pre><code>{\n  \"detail\": [\n    {\n      \"loc\": [\"body\", \"username\"],\n      \"msg\": \"field required\",\n      \"type\": \"value_error.missing\"\n    }\n  ]\n}\n</code></pre> <ul> <li>Errors include location, message, and error type.</li> <li>You can customize error handling by overriding exception handlers if needed.</li> </ul>"},{"location":"pydantic/integration/fastapi_integration/#8-summary","title":"8. Summary","text":"Feature Description Request/Response Models Define data schemas with Pydantic models Query/Path Parameter Validation Use Pydantic types and <code>Field</code> constraints Nested Models Validate complex nested JSON structures Response Model Customization Control fields included/excluded in responses Union and Optional Types Support flexible and optional fields Automatic Validation Errors FastAPI returns detailed validation errors"},{"location":"pydantic/integration/fastapi_integration/#references","title":"References","text":"<ul> <li>FastAPI - Tutorial</li> <li>FastAPI - Request Body</li> <li>FastAPI - Query Parameters</li> <li>Pydantic - Models</li> <li>FastAPI - Handling Errors</li> </ul> <p>This document provides an overview of integrating Pydantic models with FastAPI to build robust, validated, and well-documented APIs quickly and efficiently.</p>"},{"location":"pydantic/integration/orm_mode/","title":"ORM Mode","text":""},{"location":"pydantic/integration/orm_mode/#orm-mode","title":"ORM Mode","text":"<p>Pydantic's ORM mode allows models to be created from arbitrary class instances (such as ORM models) instead of just dictionaries. This is especially useful when integrating with ORMs like SQLAlchemy or Django ORM.</p>"},{"location":"pydantic/integration/orm_mode/#1-enabling-orm-mode","title":"1. Enabling ORM Mode","text":"<p>To enable ORM mode, set <code>orm_mode = True</code> in the model's <code>Config</code> class.</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    username: str\n\n    class Config:\n        orm_mode = True\n</code></pre>"},{"location":"pydantic/integration/orm_mode/#2-using-orm-mode-with-sqlalchemy-models","title":"2. Using ORM Mode with SQLAlchemy Models","text":"<p>Suppose you have an SQLAlchemy model like this:</p> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass UserORM(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True)\n    username = Column(String)\n</code></pre> <p>You can create a Pydantic model with ORM mode enabled to parse instances of <code>UserORM</code>:</p> <p>Pydantic model with ORM mode enabled</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    username: str\n\n    class Config:\n        orm_mode = True\n</code></pre> <p>Example usage</p> <pre><code>user_orm = UserORM(id=1, username=\"alice\")\nuser = User.from_orm(user_orm)\nprint(user)\n</code></pre> <p>Output:</p> <pre><code>id=1 username='alice'\n</code></pre>"},{"location":"pydantic/integration/orm_mode/#3-benefits-of-orm-mode","title":"3. Benefits of ORM Mode","text":"<ul> <li>Allows Pydantic models to be populated from ORM instances directly.</li> <li>Enables seamless serialization of ORM objects in FastAPI responses.</li> <li>Avoids manual conversion of ORM models to dicts before validation.</li> </ul>"},{"location":"pydantic/integration/orm_mode/#4-important-notes","title":"4. Important Notes","text":"<ul> <li>The ORM model attributes must match the Pydantic model fields by name.</li> <li>Nested ORM models can also be parsed if nested Pydantic models have <code>orm_mode</code> enabled.</li> <li>Use <code>.from_orm()</code> method to create Pydantic models from ORM instances.</li> </ul>"},{"location":"pydantic/integration/orm_mode/#5-example-with-nested-orm-models","title":"5. Example with Nested ORM Models","text":"<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom pydantic import BaseModel\n\nBase = declarative_base()\n\nclass AddressORM(Base):\n    __tablename__ = \"addresses\"\n\n    id = Column(Integer, primary_key=True)\n    street = Column(String)\n    city = Column(String)\n\nclass UserORM(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True)\n    username = Column(String)\n    address = relationship(\"AddressORM\", uselist=False)  # Assuming one-to-one relationship\n\nclass Address(BaseModel):\n    street: str\n    city: str\n\n    class Config:\n        orm_mode = True\n\nclass User(BaseModel):\n    id: int\n    username: str\n    address: Address\n\n    class Config:\n        orm_mode = True\n</code></pre> <p>Usage</p> <pre><code># Usage\nuser_orm = UserORM(\n    id=1,\n    username=\"alice\",\n    address=AddressORM(street=\"Main St\", city=\"Springfield\")\n)\nuser = User.from_orm(user_orm)\nprint(user)\n</code></pre>"},{"location":"pydantic/integration/orm_mode/#references","title":"References","text":"<ul> <li>Pydantic ORM Mode Documentation</li> <li>FastAPI and SQLAlchemy Integration</li> </ul> <p>This document explains how to use Pydantic's ORM mode to integrate with ORM libraries, enabling easy and efficient data validation and serialization from ORM models.</p>"},{"location":"pymongo/overview/","title":"Overview","text":""},{"location":"pymongo/overview/#overview","title":"Overview","text":"Warning <p>Motor will be deprecated on May 14th, 2026, one year after the production release of the PyMongo Async driver. Critical bug fixes will be made until May 14th, 2027. We strongly recommend that Motor users migrate to the PyMongo Async driver while Motor is still supported. To learn more, see the migration guide.</p> <ul> <li>Reference</li> </ul> <p>PyMongo and the PyMongo Async API are different in that PyMongo is traditionally a synchronous MongoDB driver, while the PyMongo Async API provides asynchronous support using Python's <code>async/await</code> syntax.</p> Key differences include: <ul> <li> <p>PyMongo (synchronous): Operations block the execution until completion, suitable for traditional synchronous programming.</p> </li> <li> <p>PyMongo Async API: Introduced in <code>PyMongo 4.13.0</code>, it offers an <code>AsyncMongoClient</code> class that allows non-blocking, asynchronous database operations using <code>await</code>. This enables integration with Python's asyncio framework for concurrent I/O without blocking the event loop.</p> </li> <li> <p>The Async API connects to MongoDB on demand (when the first operation is awaited), similar to how Motor worked but now integrated directly into PyMongo.</p> </li> <li> <p>Unlike Motor, which is a separate asynchronous driver that will be deprecated by mid-2026, the PyMongo Async API is the official async driver moving forward.</p> </li> </ul> Package Installation Command Notes PyMongo (sync) <code>python -m pip install pymongo</code> Latest stable version with synchronous API PyMongo Async API Included in PyMongo 4.13.0+ (no separate install) Use async features from PyMongo package <ul> <li>Differences between Motor and PyMongo</li> <li>Gist: pymongo vs Motor</li> <li>Perplexity: Is the Motor library still recommended for FastAPI projects now</li> </ul>"},{"location":"starlette/installation/","title":"Installation","text":""},{"location":"starlette/installation/#installation","title":"Installation","text":"<pre><code>$ pip install starlette\n</code></pre> <p>You'll also want to install an ASGI server, such as uvicorn, daphne, or hypercorn.</p> <pre><code>$ pip install uvicorn\n</code></pre>"},{"location":"starlette/installation/#example","title":"Example","text":"<pre><code>from starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\n\nasync def homepage(request):\n    return JSONResponse({'hello': 'world'})\n\nroutes = [\n    Route(\"/\", endpoint=homepage)\n]\n\napp = Starlette(debug=True, routes=routes)\n</code></pre> <p>Then run the application using Uvicorn:</p> <pre><code>$ uvicorn main:app\n</code></pre>"},{"location":"starlette/installation/#dependencies","title":"Dependencies","text":"<p>Starlette only requires <code>anyio</code>, and the following are optional:</p> <ul> <li>httpx - Required if you want to use the <code>TestClient</code>.</li> <li>jinja2 - Required if you want to use <code>Jinja2Templates</code>.</li> <li>python-multipart - Required if you want to support form parsing, with <code>request.form()</code>.</li> <li>itsdangerous - Required for <code>SessionMiddleware</code> support.</li> <li>pyyaml - Required for <code>SchemaGenerator</code> support.</li> </ul> <p>You can install all of these with <code>pip install starlette[full]</code>.</p>"},{"location":"starlette/installation/#reference","title":"Reference","text":"<ul> <li>Github: starlette</li> </ul>"},{"location":"starlette/overview/","title":"Overview","text":""},{"location":"starlette/overview/#starlette","title":"Starlette","text":"<p>Starlette is a lightweight ASGI framework/toolkit, which is ideal for building async web services in Python.</p>"},{"location":"starlette/overview/#reference","title":"Reference","text":"<ul> <li>Mkdocs: Starlette</li> <li>Github: Starlette</li> </ul>"},{"location":"strawberry-graphql/80-20-principle/","title":"80/20 Principle","text":""},{"location":"strawberry-graphql/80-20-principle/#80-20-principle","title":"80 20 Principle","text":"<p>Great question! If you're looking to learn Strawberry GraphQL efficiently using the 80/20 principle (Pareto Principle), the goal is to focus on the 20% of features and concepts that give you 80% of the practical value\u2014enough to build useful APIs quickly.</p>"},{"location":"strawberry-graphql/80-20-principle/#what-is-strawberry-graphql","title":"\ud83c\udf53 What is Strawberry GraphQL?","text":"<p>Strawberry is a modern Python library for building GraphQL APIs, using Python type hints and dataclasses.</p>"},{"location":"strawberry-graphql/80-20-principle/#8020-learning-plan-for-strawberry-graphql","title":"\ud83e\udde0 80/20 Learning Plan for Strawberry GraphQL","text":"<p>Here\u2019s a breakdown of what to focus on first:</p>"},{"location":"strawberry-graphql/80-20-principle/#the-essential-20-learn-first","title":"\u2705 The Essential 20% (Learn First)","text":"<p>1. Schema Basics with <code>@strawberry.type</code></p> <ul> <li> <p>How to define types and fields using Python dataclasse</p> <pre><code>import strawberry\n\n@strawberry.type\nclass Book:\n    title: str\n    author: str\n</code></pre> </li> </ul> <p>2. Query Basics</p> <ul> <li> <p>How to define query entry points</p> <pre><code>@strawberry.type\nclass Query:\n    @strawberry.field\n    def hello(self) -&gt; str:\n        return \"Hello, world!\"\n</code></pre> </li> <li> <p>Create and serve schema:</p> <pre><code>schema = strawberry.Schema(query=Query)\n</code></pre> </li> </ul> <p>3. Running the Server (e.g., with FastAPI or standalone)</p> bash<pre><code>pip install strawberry-graphql[fastapi]\n</code></pre> python<pre><code>from fastapi import FastAPI\nfrom strawberry.fastapi import GraphQLRouter\n\napp = FastAPI()\ngraphql_app = GraphQLRouter(schema)\n\napp.include_router(graphql_app, prefix=\"/graphql\")\n</code></pre> <p>Then access at http://localhost:8000/graphql.</p> <p>4. Basic Arguments and Return Types</p> python<pre><code>@strawberry.field\ndef book_by_title(self, title: str) -&gt; Optional[Book]:\n    return next((b for b in books if b.title == title), None)\n</code></pre> <p>5. Simple Lists and Nested Types</p> python<pre><code>@strawberry.field\ndef all_books(self) -&gt; list[Book]:\n    return books\n</code></pre>"},{"location":"strawberry-graphql/80-20-principle/#optional-advanced-80-learn-as-needed","title":"\ud83d\udca1 Optional Advanced 80% (Learn As Needed)","text":"<p>If and when your use case expands, learn these in order:</p> <ul> <li>Mutations (<code>@strawberry.mutation</code>)</li> <li>Input types (<code>@strawberry.input</code>)</li> <li>Context (<code>info.context</code>)</li> <li>Authorization/Authentication</li> <li>Custom scalars and enums</li> <li>Error handling</li> <li>Subscriptions (WebSockets)</li> <li>Federation (for microservices)</li> <li>Performance tuning (e.g., dataloaders)</li> </ul>"},{"location":"strawberry-graphql/80-20-principle/#resources-to-use","title":"\ud83d\udcda Resources to Use","text":"<ul> <li>Official Docs: https://strawberry.rocks/docs</li> <li>Strawberry GitHub: https://github.com/strawberry-graphql/strawberry</li> <li>Minimal Demo Projects on GitHub (search \"strawberry graphql example\")</li> <li>FastAPI + Strawberry tutorials (if using together)</li> </ul>"},{"location":"strawberry-graphql/80-20-principle/#suggested-learning-plan-23-hours-total","title":"\ud83d\uddfa Suggested Learning Plan (2\u20133 Hours Total)","text":"Time Focus 30 min Read the Strawberry Quickstart 30 min Build a query-only API with a couple of types 1 hour Add arguments, lists, and one mutation 30 min Connect to FastAPI and test in Playground <p>Let me know if you want a customized tutorial or template repo to get started fast.</p>"},{"location":"strawberry-graphql/anatomy-of-a-graphql-server/","title":"Anatomy of GraphQL","text":""},{"location":"strawberry-graphql/anatomy-of-a-graphql-server/#anatomy-of-a-graphql-server","title":"Anatomy of a GraphQL server","text":"<p>The GraphQL server is where all the magic happens. Let's dive deeper into the components that make it up.</p>"},{"location":"strawberry-graphql/anatomy-of-a-graphql-server/#reference","title":"Reference","text":"<ul> <li>Journey of a GraphQL operation</li> </ul>"},{"location":"strawberry-graphql/overview/","title":"Overview","text":""},{"location":"strawberry-graphql/overview/#overview","title":"Overview","text":"<p>Strawberry GraphQL is a modern Python library for building GraphQL APIs using type hints (introduced in Python 3.6+). It focuses on developer ergonomics and Pythonic design, making it easier to build GraphQL APIs with Python, especially using features like <code>dataclasses</code> and <code>async</code> support.</p>"},{"location":"strawberry-graphql/overview/#what-is-strawberry-graphql","title":"\ud83d\udd0d What Is Strawberry GraphQL?","text":"<ul> <li>Language: Python</li> <li>Main Feature: Uses Python type hints to define your GraphQL schema.</li> <li>Framework Integration: Works with popular frameworks like FastAPI, Django, Flask, and ASGI.</li> <li>Developer Friendly: Designed to feel native to Python developers, making it easy to learn and use.</li> <li>Built-in GraphQL Playground: Provides a UI for testing queries and mutations.</li> </ul> <pre><code>import strawberry\nfrom fastapi import FastAPI\nfrom strawberry.fastapi import GraphQLRouter\n\n@strawberry.type\nclass Query:\n    @strawberry.field\n    def hello(self) -&gt; str:\n        return \"Hello, world!\"\n\nschema = strawberry.Schema(query=Query)\ngraphql_app = GraphQLRouter(schema)\n\napp = FastAPI()\napp.include_router(graphql_app, prefix=\"/graphql\")\n</code></pre>"},{"location":"strawberry-graphql/overview/#summary-comparison","title":"\ud83d\udd04 Summary: Comparison","text":"Feature Strawberry Graphene Ariadne Type Hints \u2705 Native support \u274c Not supported \u26a0\ufe0f Partial Schema Style Code-first Code-first Schema-first Async Support \u2705 Yes \u26a0\ufe0f Limited \u2705 Yes Integration FastAPI, Django Django, Flask ASGI, Starlette Learning Curve \ud83d\udfe2 Easy \ud83d\udfe0 Medium \ud83d\udfe0 Medium <p>If you're starting fresh and enjoy Python's type hints and FastAPI/Django, Strawberry is a modern and enjoyable choice. If you're using Django heavily and need a mature ecosystem, Graphene is worth a look. For SDL purists or those working with a microservice architecture, Ariadne offers flexibility and control.</p>"},{"location":"strawberry-graphql/setup/","title":"Setup","text":""},{"location":"strawberry-graphql/setup/#setup","title":"Setup","text":"Installation<pre><code>pip install strawberry-graphql\n</code></pre> <p>GraphQL (1) by itself is a specification, a query language for APIs. To implement GraphQL in a server, we typically use a GraphQL framework.</p> <ol> <li>An open-source query language and specification for APIs that enables clients to request specific data, promoting efficiency and flexibility in data retrieval.</li> </ol> <p>For example, if you're a JavaScript/TypeScript developer, you might use Apollo Server.</p> <p>In the Python ecosystem, we can use Strawberry, a GraphQL library developed and maintained by the Strawberry team. Here's how they introduce themselves:</p> <p>Strawberry is a developer friendly GraphQL library for Python, designed for modern development.</p> <p></p>"},{"location":"strawberry-graphql/setup/#project-setup","title":"Project setup","text":""},{"location":"strawberry-graphql/setup/#install-python","title":"Install Python","text":"<p>We're using <code>Python 3.12</code> in this course. While Strawberry works with <code>Python 3.8+</code>, we recommend using the latest version of Python for the best experience. Find your download link here.</p>"},{"location":"strawberry-graphql/setup/#clone-the-repo-locally","title":"Clone the repo locally","text":"<p>The project repo is a minimal template running Strawberry and FastAPI. It also contains some extra instructions in the README on how to get up and running.</p> <pre><code>git clone https://github.com/apollographql-education/odyssey-intro-strawberry\n</code></pre> <p>Here's what the project looks like:</p> <pre><code>\ud83d\udce6 odyssey-intro-strawberry\n\u2523 \ud83d\udcc2 api\n\u2503 \u2523 \ud83d\udcc2 types\n\u2503 \u2503 \u2517 \ud83d\udcc4 __init__.py\n\u2503 \u2517 \ud83d\udcc4 __init__.py\n\u2523 \ud83d\udcc2 data\n\u2503 \u2517 \ud83d\udcc4 openapi.json\n\u2523 \ud83d\udcc4 main.py\n\u2523 \ud83d\udcc4 pyproject.toml\n\u2523 \ud83d\udcc4 README.md\n\u2523 \ud83d\udcc4 requirements-dev.txt\n\u2517 \ud83d\udcc4 requirements.txt\n</code></pre> <p>Before installing the dependencies, let's set up a virtual environment to keep our project dependencies isolated from other projects.</p> <pre><code>python -m venv .venv\n</code></pre> <p>This command creates a <code>.venv</code> directory in your project folder. To activate the virtual environment, run:</p> linux/macoswindows <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\activate\n</code></pre>"},{"location":"strawberry-graphql/setup/#install-dependencies-and-run-the-server","title":"Install dependencies and run the server","text":"<p>Run the following command to install dependencies.</p> <pre><code>pip install -r requirements.txt -r requirements-dev.txt\n</code></pre> <p>Finally, let's run the project.</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Note: <code>uvicorn</code> is an ASGI server implementation, using uvloop and httptools. You can learn more about it here.</p> <p>In the terminal, you should see the output logs:</p> <pre><code>INFO:     Will watch for changes in these directories: ['/\ud83d\udc0d/odyssey-intro-strawberry']\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [54074] using StatReload\nINFO:     Started server process [54092]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre> <p>The project will be running on http://localhost:8000.</p>"},{"location":"strawberry-graphql/setup/#reference","title":"Reference","text":"<ul> <li>Official: Strawberry GraphQL</li> <li>Intro to GraphQL with Python and Strawberry</li> <li>Github: Example on how to use Strawberry </li> <li>How to Build a GraphQL API in Python</li> <li>Building GraphQL APIs with Strawberry (Part 1: Queries)</li> <li>Logrocket: Using GraphQL with Strawberry, FastAPI, and Next.js</li> <li>graphql.org: Code Using GraphQL</li> </ul>"},{"location":"strawberry-graphql/starter-template/","title":"Strater Template","text":""},{"location":"strawberry-graphql/starter-template/#starter-template","title":"Starter Template","text":"<p>Here's a customized Strawberry GraphQL + FastAPI starter tutorial and template repo to get you building fast. You can copy this structure or clone it as a base for your own projects.</p>"},{"location":"strawberry-graphql/starter-template/#strawberry-fastapi-starter-template","title":"\ud83c\udf53 Strawberry + FastAPI Starter Template","text":""},{"location":"strawberry-graphql/starter-template/#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<pre><code>strawberry-app/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 main.py          # FastAPI app with GraphQL endpoint\n\u2502   \u251c\u2500\u2500 schema.py        # Strawberry types, queries, and mutations\n\u2502   \u2514\u2500\u2500 data.py          # Sample data and models\n\u251c\u2500\u2500 requirements.txt     # Dependencies\n\u2514\u2500\u2500 README.md            # Instructions\n</code></pre>"},{"location":"strawberry-graphql/starter-template/#step-by-step-tutorial","title":"\ud83e\uddf0 Step-by-Step Tutorial","text":"<p>\u2705 1. Create and activate virtual environment</p> <pre><code>python -m venv venv\nsource venv/bin/activate  # or venv\\Scripts\\activate on Windows\n</code></pre> <p>\u2705 2. Install dependencies</p> <pre><code>pip install strawberry-graphql[fastapi] fastapi uvicorn\n</code></pre> <p>\ud83d\udd3d Optional <code>requirements.txt</code>:</p> <pre><code>fastapi\nuvicorn\nstrawberry-graphql[fastapi]\n</code></pre> <p>\u2705 3. Define Your Data and Schema</p> <p><code>app/data.py</code></p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass Book:\n    title: str\n    author: str\n\nbooks = [\n    Book(title=\"1984\", author=\"George Orwell\"),\n    Book(title=\"Brave New World\", author=\"Aldous Huxley\"),\n]\n</code></pre> <p><code>app/schema.py</code></p> <pre><code>import strawberry\nfrom app.data import books, Book as BookData\n\n@strawberry.type\nclass Book:\n    title: str\n    author: str\n\n@strawberry.type\nclass Query:\n    @strawberry.field\n    def all_books(self) -&gt; list[Book]:\n        return books\n\n    @strawberry.field\n    def book_by_title(self, title: str) -&gt; Book | None:\n        return next((b for b in books if b.title == title), None)\n\nschema = strawberry.Schema(query=Query)\n</code></pre> <p>\u2705 4. Set Up FastAPI App</p> <p><code>app/main.py</code></p> <pre><code>from fastapi import FastAPI\nfrom strawberry.fastapi import GraphQLRouter\nfrom app.schema import schema\n\napp = FastAPI()\ngraphql_app = GraphQLRouter(schema)\n\napp.include_router(graphql_app, prefix=\"/graphql\")\n</code></pre> <p>\u2705 5. Run the Server</p> <pre><code>uvicorn app.main:app --reload\n</code></pre> <p>Visit \ud83d\udc49 http://localhost:8000/graphql to test queries in the browser.</p>"},{"location":"strawberry-graphql/starter-template/#example-queries","title":"\ud83e\uddea Example Queries","text":"<p><code>Query all books</code></p> <pre><code>query {\n  allBooks {\n    title\n    author\n  }\n}\n</code></pre> <p><code>Query by title</code></p> <pre><code>query {\n  bookByTitle(title: \"1984\") {\n    title\n    author\n  }\n}\n</code></pre>"},{"location":"strawberry-graphql/starter-template/#optional-github-repo-template","title":"\ud83d\udce6 Optional: GitHub Repo Template","text":"<p>You can also use this as a GitHub template, or I can generate one for you and share a downloadable ZIP or GitHub repo link \u2014 just let me know your preference (GitHub or ZIP download).</p> <p>Would you like this scaffold as a downloadable project or pushed to a GitHub repo?</p>"},{"location":"strawberry-graphql/starter-template/#starter-templates-for-fastapi-strawberry-graphql","title":"\ud83d\ude80 Starter Templates for FastAPI + Strawberry GraphQL","text":"<p>1. Basic FastAPI + Strawberry Template</p> <ul> <li>Description: A minimal setup to get you started with FastAPI and Strawberry GraphQL.</li> <li>Features: Simple integration, ideal for learning and small projects.</li> <li>Repository: strawberry-graphql/strawberry-fastapi-template</li> </ul> <p>2. FastAPI + Strawberry + SQLAlchemy Boilerplate</p> <ul> <li>Description: A production-ready template integrating FastAPI, Strawberry, and SQLAlchemy for asynchronous operations.</li> <li>Features: Async SQLAlchemy, CRUD operations, Docker support, and unit tests.</li> <li>Repository: syedfaisalsaleeem/FastApi-Strawberry-GraphQL-SqlAlchemy-BoilerPlate</li> </ul> <p>3. FastAPI + Strawberry + MongoDB Template</p> <ul> <li>Description: A template combining FastAPI, Strawberry, and MongoDB, utilizing Docker for containerization.</li> <li>Features: MongoDB integration, Docker Compose setup, example queries and mutations.</li> <li>Repository: bhavberi/FastAPI-Graphql-Strawberry-Mongodb-Template</li> </ul> <p>4. FastAPI + Strawberry + PostgreSQL with SQLModel</p> <ul> <li>Description: A template using FastAPI, Strawberry, SQLModel, and PostgreSQL, designed for Kubernetes deployment.</li> <li>Features: SQLModel ORM, PostgreSQL database, Kubernetes deployment, Helm charts.</li> <li>Repository: ocni-dtu/strawberry_template</li> </ul> <p>5. FastAPI + Strawberry + React (Frontend)</p> <ul> <li>Description: A full-stack template with FastAPI and Strawberry on the backend, and React with URQL on the frontend.</li> <li>Features: Full-stack setup, Docker Compose, hot-reloading for development.</li> <li>Repository: jmgraff/fastapi-strawberry-urql</li> </ul>"},{"location":"type-hinting/history/","title":"History","text":""},{"location":"type-hinting/history/#overview","title":"Overview","text":""},{"location":"type-hinting/history/#python-type-hints","title":"Python Type Hints","text":"<p>Python type hinting is a very important and relatively new feature of the language that facilitates the work of developers, bringing greater robustness and maintainability to the development workflow.</p> <p>Types make your code more readable and understandable, and most importantly, they promote good practices.</p> <p>FastAPI is heavily based on Python type hints. So, before diving into the framework, it is useful to review the basic concepts of type hinting, what they are, how they are implemented, and what their purpose is. This foundational knowledge will help you create robust, maintainable, and scalable APIs with FastAPI. (1)</p> <ol> <li>Full Stack FastAPI, React, and MongoDB, Second edition by Marko Aleksendri\u0107, Ph.D.</li> </ol>"},{"location":"type-hinting/history/#python-types","title":"Python types","text":"<p>The different types present in a programming language define the language itself\u2014they define its boundaries and set some ground rules for what is possible and, more importantly, what the recommended way of achieving something is. Different types of variables have completely different sets of methods and properties available. For example, while capitalizing a string makes perfect sense, capitalizing a floating number or a list of integers doesn\u2019t.</p> <p>If you have used Python for a while, even for the most mundane tasks, you already know that, like every programming language, it supports different types of data\u2014strings and different numerical types such as integers and floats. It also features a rather rich data structure library: from dictionaries to lists, from sets to tuples, and so on.</p> <p>Python is a dynamically typed language. This means that the type of a variable is not determined at compile time, but at runtime. This feature gives the language itself a lot of flexibility and enables you to declare a variable as a string, use it, and then later on reassign it to a list. However, the ease of changing the variable type can make larger and more complex codebases more prone to errors. Dynamic typing implies that the type of a variable is embedded with the variable itself and is easily modifiable.</p> <p>On the other end of the spectrum lie the so-called statically typed languages: <code>C</code>, <code>C++</code>, <code>Java</code>, <code>Rust</code>, <code>Go</code>, and so on. In these languages, the type of the variable is known at compile time, and it cannot change over time. The type-checking is performed at compile time (so before runtime) and errors are caught before runtime, as the compiler will prevent the program from being compiled.</p> <p>Programming languages are divided into different categories along another, different axis: strongly typed languages and weakly typed languages. This characteristic tells us how much a language restricts its types to operations inherent to those specific types and how easy it is to <code>coerce</code>, or <code>change</code>, a variable from one to another type. Unlike JavaScript, for instance, Python is considered to be on the stronger side of the spectrum, and the interpreter sends strong messages when you try to perform an illegal operation, such as typing the following in a Python interpreter to add a <code>dict</code> type to a number:</p> <pre><code>&gt;&gt;&gt;{}+3\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for +: 'dict' and 'int'\n</code></pre> <p>So, while Python does complain when you attempt to perform unsupported operations, it only does so at runtime, not before executing the code. In fact, there is no indication to you\u2014the developer \u2014 that you are writing code that violates the Python type system.</p>"},{"location":"type-hinting/history/#type-hinting","title":"Type hinting","text":"<p>As you have seen in the previous section, Python is a dynamically typed language, and types aren\u2019t known until runtime. Since variable types are embedded in the value of the variable itself, as a developer, you cannot know the type of a variable that you encounter in a codebase just by looking at it or inspecting it with your IDE of choice. Fortunately, Python introduced a very sought-out feature starting from version 3.5\u2014type annotations (https://peps.python.org/pep-0484/).</p> <p>Type annotations or hints in Python are an additional syntax that notifies you, the developer, of the expected type of a variable. They are not used by the Python language at runtime, and they do not modify or affect the behavior of your program in any way. You might be wondering what the use of these hints is if the Python interpreter cannot even see them.</p> <p>As it turns out, several important benefits will make almost any codebase much more robust, more maintainable, and future-proof:</p> <ul> <li>Faster code development</li> <li>Knowledge of methods and properties</li> <li>Simplified code development:</li> <li>Automatic code generation</li> <li>Type checkers</li> <li>Easier to read and smaller cognitive load</li> <li>Strongly typed and flexible</li> </ul> <p>Type hinting is at the very base of FastAPI. Coupled with MongoDB\u2019s flexible document schema, it is the backbone of FARM stack development. Type hinting ensures that your application data flow maintains the right data types going in and out of the system at every moment. While this might seem trivial for simpler endpoints\u2014quantities should be integers, names should be strings, and so on\u2014when your data structure becomes more complex, debugging type errors can become very cumbersome.</p> <p>Type hints can also be defined as a formalism\u2014a formal solution to statically (before runtime) indicate the type of a value to a type checker (Mypy, in your case), which will ensure that when the Python runtime encounters your program the types will not be problematic.</p>"},{"location":"type-hinting/history/#implementing-type-hints","title":"Implementing type hints","text":"<p>Let\u2019s see how you can implement type hinting.</p> <pre><code>mypy==1.10.0\npydantic==2.7.4\n</code></pre> <p>While there are many Python type checkers \u2014 basically tools that perform static analysis of the source code without running it \u2014 we will use mypy as it is easily installable. Later, you will have tools such as Black or Ruff at your disposal. These perform different actions on your source code, including type checking.</p> <pre><code>def print_name_x_times(name: str, times: int) -&gt; None:\n\u202f\u202f\u202f\u202ffor _ in range(times):\n\u202f\u202f\u202f\u202f\u202f\u202f\u202f\u202fprint(name)\n</code></pre> <p>The previous function accepts two parameters, name (a <code>string</code>) and times (an <code>integer</code>), and returns <code>None</code>, while the function prints the given name for a given number of times in the console. If you try to call the function in your code and start typing the arguments, Visual Studio Code (or any IDE with Python type-checking support) will immediately suggest a string as the first positional argument and an integer as the second.</p> <pre><code>def count_users(users: list[str]) -&gt; int:\n\u202f\u202f\u202f\u202freturn len(users)\n</code></pre> <p>So far, you have seen simple annotations that constrain a variable to some Python primitive types including <code>integers</code> and <code>strings</code>. Typing annotations can be more flexible: you might want to allow a variable to accept several variable types, such as an <code>integer</code> and a <code>string</code>.</p> <p>You can achieve this with the use of the Union package from the typing module:</p> <pre><code>from typing import Union\nx: Union(str, int)\n</code></pre> <p>The previously defined <code>x</code> variable can take a string or an integer value. The more modern and concise way of achieving the same functionality is the following:</p> <pre><code>x: str | int\n</code></pre> <p>These annotations mean that the variable x can be an integer or it can take a value of string, which is a different type from an integer.</p> <p>The typing module contains several types of so-called generics, including the following:</p> <ul> <li><code>List</code>: For variables that should be of the list type</li> <li><code>Dict</code>: For dictionaries</li> <li><code>Sequence</code>: For any type of sequence of values</li> <li><code>Callable</code>: For callables, such as functions</li> <li><code>Iterator</code>: Indicates that a function or variable accepts an iterator object (an object that implements the iterator protocol and can be used in a for loop)</li> </ul> Note <p>You are encouraged to explore the <code>typing</code> ==module ==but bear in mind that the types from the module are gradually being imported into Python\u2019s code functionality.</p> <p>For instance, the <code>List</code> type is very useful in working with FastAPI as it allows you to serialize a list of items or resources quickly and efficiently into a JSON output.</p> <pre><code>from typing import List\ndef square_numbers(numbers: List[int]) -&gt; List[int]:\n\u202f\u202f\u202f\u202freturn [number ** 2 for number in numbers]\n# Example usage\ninput_numbers = [1, 2, 3, 4, 5]\nsquared_numbers = square_numbers(input_numbers)\nprint(squared_numbers)\u202f\u202f# Output: [1, 4, 9, 16, 25]\n</code></pre>"},{"location":"type-hinting/history/#advanced-annotations","title":"Advanced annotations","text":"<p>The annotations you have seen so far are very simple and convey basic information related only to the specific desired type of a variable, function, class argument, or output. Python\u2019s typing system is capable of much more and it can be used to restrict the allowable variables' state further and prevent you, the developer, from creating impossible or illegal states in your code.</p> <p>The most frequently used types are the following:</p> <ul> <li>The <code>Optional</code> type is used for handling optional values and <code>None</code> values in an explicit and developer-friendly way.</li> <li>The <code>Union</code> type allows you to define a union of possible types, such as integers and strings. Modern Python uses the pipe operator (<code>|</code>), as shown in the previous example.</li> <li>The <code>self</code> type is used to indicate that the value will be an instance of a certain class, useful in Pydantic model validators as we will see later.</li> <li>The <code>New</code> type allows developers to define completely new types based on existing types.</li> </ul> <p>This section detailed Python type hints, their purpose, and how they are implemented. The next section will take a deeper look at Pydantic, the workhorse of FastAPI data validation.</p>"},{"location":"type-hinting/history/#reference","title":"Reference","text":"<ul> <li>Full Stack FastAPI, React, and MongoDB, Second edition by Marko Aleksendri\u0107, Ph.D.</li> </ul>"},{"location":"type-hinting/intro/","title":"Introduction to Type Hints","text":""},{"location":"type-hinting/intro/#introduction-to-type-hints","title":"Introduction to Type Hints","text":"<p>Type hints were introduced in Python 3.5 via PEP 484 to provide a standard way of annotating Python code with information about the expected types of variables, function parameters, and return values. They are optional and do not affect the runtime behavior of the program but enable static type checkers, IDEs, and linters to analyze code for potential type errors.</p>"},{"location":"type-hinting/intro/#why-use-type-hints","title":"Why Use Type Hints?","text":"<ul> <li>Improved Readability: Makes the code easier to understand by explicitly stating the expected types.</li> <li>Early Error Detection: Helps catch bugs before runtime using static type checkers like <code>mypy</code>.</li> <li>Better Tooling: IDEs can provide better autocompletion, refactoring, and documentation support.</li> <li>Documentation: Serves as a form of documentation for function interfaces and variable types.</li> </ul>"},{"location":"type-hinting/intro/#basic-syntax","title":"Basic Syntax","text":"<p>Type hints use annotations with a colon (<code>:</code>) after variable names or function parameters, and an arrow (<code>-&gt;</code>) to indicate the return type.</p> <pre><code>def greet(name: str) -&gt; str:\n    return 'Hello, ' + name\n\nage: int = 25\n</code></pre> <ul> <li><code>name: str</code> indicates that <code>name</code> should be a string.</li> <li><code>-&gt; str</code> indicates the function returns a string.</li> <li><code>age: int</code> declares that <code>age</code> is an integer variable.</li> </ul>"},{"location":"type-hinting/intro/#type-hints-for-functions","title":"Type Hints for Functions","text":"<p>You can annotate function parameters and return types:</p> <pre><code>def add(x: int, y: int) -&gt; int:\n    return x + y\n</code></pre> <ul> <li>Both <code>x</code> and <code>y</code> are expected to be integers.</li> <li>The function returns an integer.</li> </ul>"},{"location":"type-hinting/intro/#optional-types","title":"Optional Types","text":"<p>To indicate a variable or parameter can be of a certain type or <code>None</code>, use <code>Optional</code> from the <code>typing</code> module:</p> <pre><code>from typing import Optional\n\ndef find_user(user_id: int) -&gt; Optional[str]:\n    # Simulated user database\n    users = {\n        1: \"Alice\",\n        2: \"Bob\",\n        3: \"Charlie\"\n    }\n    # Return the username if found, else None\n    return users.get(user_id)\n</code></pre> <p>This means the function returns either a <code>str</code> or <code>None</code>.</p>"},{"location":"type-hinting/intro/#complex-types","title":"Complex Types","text":"<p>The <code>typing</code> module provides many generic types to express complex data structures:</p> <pre><code>from typing import List, Dict, Tuple\n\nnames: List[str] = ['Alice', 'Bob']\nscores: Dict[str, int] = {'Alice': 90, 'Bob': 85}\ncoordinates: Tuple[int, int] = (10, 20)\n</code></pre>"},{"location":"type-hinting/intro/#type-checking-tools","title":"Type Checking Tools","text":"<p>Type hints are not enforced at runtime but can be checked using tools like:</p> <ul> <li><code>mypy</code></li> <li><code>pyright</code></li> <li>IDEs like PyCharm, VSCode, and others provide type hint support.</li> </ul>"},{"location":"type-hinting/intro/#summary","title":"Summary","text":"Feature Description Optional Type hints are optional Static Analysis Tools can catch type errors before runtime <code>typing</code> Module Provides complex and generic type hints Improved Readability Makes code easier to understand Better Tooling Enhanced IDE support and autocompletion"},{"location":"type-hinting/intro/#references","title":"References","text":"<ul> <li>PEP 484 \u2013 Type Hints</li> <li>Typing - Type Hints</li> <li>Mypy \u2013 Optional Static Typing for Python</li> </ul> <p>This introduction provides a foundation for understanding and using type hints effectively in Python projects.</p>"},{"location":"type-hinting/typing-module/","title":"Typing Module","text":""},{"location":"type-hinting/typing-module/#the-typing-module","title":"The <code>typing</code> module","text":"<p>The <code>typing</code> module is built-in since <code>Python 3.5</code> and remains essential for advanced annotations, but for common generics, built-in types are preferred in modern Python versions.</p> <p>The <code>typing</code> module has been included in the Python standard library since <code>Python 3.5</code>, so you do not need to install it separately if you are using <code>Python 3.5</code> or newer.</p> <p>For Python versions older than <code>3.5</code>, the typing module is available as a backport package on PyPI that you can install manually.</p> In summary <ul> <li>Python 3.5 and later: <code>typing</code> is built-in, no installation required.</li> <li>Before Python 3.5: install the <code>typing</code> package from PyPI if you want to use type hints.</li> </ul> <p>Additionally, newer features added to typing in recent Python releases may require the <code>typing_extensions</code> package to backport those features to older Python versions.</p>"},{"location":"type-hinting/typing-module/#type-hinting-and-type-checking-with-mypy","title":"Type hinting and type checking with mypy","text":"<p>In the first section of this chapter, we said that Python was a dynamically typed language: the interpreter doesn't check types at compile time but rather at runtime. This makes the language a bit more flexible and the developer a bit more efficient. However, if you are experienced with that kind of language, you probably know that it's easy to produce errors and bugs in this context: forgetting arguments and type mismatch.</p> <p>This is why Python introduced type hinting starting with version 3.5. The goal is to provide a syntax to annotate the source code with type annotations: each <code>variable</code>, <code>function</code>, and <code>class</code> can be annotated to give indications about the types they expect. This doesn't mean that Python becomes a statically typed language. Those annotations remain completely optional and are ignored by the interpreter. However, those annotations can be used by static-type checkers, which will check whether your code is valid and consistent following the annotations. Hence, it greatly helps you to reduce errors and write self-explanatory code.</p> <p>One of those tools, mypy, is widely used by the community in this context.</p> <pre><code>pip install mypy\n</code></pre> <ul> <li> pg-48</li> <li>Github: mypy</li> </ul> <p>You understand the basics of type hinting in Python. We'll now review more advanced examples, especially with non-scalar types.</p>"},{"location":"type-hinting/typing-module/#the-typing-module_1","title":"The typing module","text":"<p>So far, we've seen how to annotate variables for scalar types such as str or int. But we've seen that there are data structures such as lists and dictionaries that are widely used in Python. For those and other types of utilities, Python introduced the typing module.</p> <p>In the following example, we'll show how to type hint basic data structures in Python:</p> <pre><code>from typing import Dict, List, Set, Tuple\n\nl: List[int] = [1, 2, 3, 4, 5]\n\nt: Tuple[int, str, float] = (1, \"hello\", 3.14)\n\ns: Set[int] = {1, 2, 3, 4, 5}\n\nd: Dict[str, int] = {\"a\": 1, \"b\": 2, \"c\": 3}\n</code></pre> <p>The <code>typing</code> module contains classes for type hinting <code>lists</code>, <code>tuples</code>, <code>sets</code>, and <code>dictionaries</code>.</p> <p>You simply have to import it and use it in your annotations. In this case, those classes expect you to provide the type of the values composing your structure. It's the same as the well-known concept of generics in object-oriented programming. In Python, they are defined using square brackets.</p>"},{"location":"type-hinting/typing-module/#reference","title":"Reference","text":"<ul> <li>Building Data Science Applications with FastAPI by Fran\u00e7ois Voron</li> </ul>"},{"location":"type-hinting/advanced/generics/","title":"Generics","text":""},{"location":"type-hinting/advanced/generics/#generics-in-python-type-hints","title":"Generics in Python Type Hints","text":"<p>Generics allow you to write flexible and reusable code by parameterizing types. Instead of specifying concrete types, you can define functions, classes, or data structures that work with any type while still maintaining type safety.</p>"},{"location":"type-hinting/advanced/generics/#what-are-generics","title":"What Are Generics?","text":"<p>Generics enable you to define type variables that can be substituted with any type. This is useful when writing container classes or functions that operate on multiple types.</p>"},{"location":"type-hinting/advanced/generics/#using-typevar","title":"Using <code>TypeVar</code>","text":"<p>The <code>TypeVar</code> class from the <code>typing</code> module is used to declare a generic type variable.</p> <pre><code>from typing import TypeVar, List\n\nT = TypeVar('T')  # Declare a type variable\n\ndef first_element(lst: List[T]) -&gt; T:\n    return lst[0]  # Return the first element of the list\n</code></pre> <p>In this example:</p> <ul> <li><code>T</code> is a type variable that can represent any type.</li> <li>The function <code>first_element</code> accepts a list of any type <code>T</code> and returns an element of the same type.</li> </ul>"},{"location":"type-hinting/advanced/generics/#generic-classes","title":"Generic Classes","text":"<p>You can also create generic classes using <code>TypeVar</code> and <code>Generic</code>.</p> <pre><code>from typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Box(Generic[T]):\n    def __init__(self, content: T) -&gt; None:  # Corrected __init__ method name\n        self.content = content\n\n    def get_content(self) -&gt; T:\n        return self.content\n\n# Creating instances of Box with specific types\nint_box = Box[int](123)       # Box containing an int\nstr_box = Box[str](\"Hello\")   # Box containing a str\n</code></pre> <p>Here:</p> <ul> <li><code>Box</code> is a generic class that can hold any type <code>T</code>.</li> <li>When creating instances, you specify the concrete type, e.g., <code>Box[int]</code> or <code>Box[str]</code>.</li> </ul>"},{"location":"type-hinting/advanced/generics/#bounded-type-variables","title":"Bounded Type Variables","text":"<p>You can restrict a type variable to a specific type or its subclasses using bounds.</p> <pre><code>from typing import TypeVar\n\nclass Animal:\n    def speak(self) -&gt; None:\n        print(\"Animal sound\")\n\nT = TypeVar('T', bound=Animal)\n\ndef make_speak(animal: T) -&gt; None:\n    animal.speak()\n</code></pre> <p>This means <code>T</code> can only be <code>Animal</code> or its subclasses.</p>"},{"location":"type-hinting/advanced/generics/#covariance-and-contravariance","title":"Covariance and Contravariance","text":"<p>Generics support variance to specify how subtyping between generic types relates to subtyping between their parameters.</p> <ul> <li>Covariant (<code>covariant=True</code>): Allows a generic type to be substituted with its subtype.</li> <li>Contravariant (<code>contravariant=True</code>): Allows a generic type to be substituted with its supertype.</li> </ul> <p>Example:</p> <pre><code>from typing import TypeVar, Generic\n\nT_co = TypeVar('T_co', covariant=True)\n\nclass ReadOnlyBox(Generic[T_co]):\n    def __init__(self, content: T_co) -&gt; None:\n        self._content = content\n\n    def get_content(self) -&gt; T_co:\n        return self._content\n</code></pre>"},{"location":"type-hinting/advanced/generics/#summary","title":"Summary","text":"Concept Description Example <code>TypeVar</code> Declare a generic type variable <code>T = TypeVar('T')</code> Generic Functions Functions parameterized by type variables <code>def func(x: T) -&gt; T</code> Generic Classes Classes parameterized by type variables <code>class Box(Generic[T])</code> Bounded Type Variables Restrict type variables to subclasses <code>T = TypeVar('T', bound=Base)</code> Variance Control subtyping relationships in generics <code>TypeVar('T_co', covariant=True)</code> <p>Generics are powerful tools for writing flexible, reusable, and type-safe Python code. Understanding and using them effectively can greatly improve your code quality.</p>"},{"location":"type-hinting/advanced/protocols/","title":"Protocols and Structural Subtyping","text":""},{"location":"type-hinting/advanced/protocols/#protocols-and-structural-subtyping","title":"Protocols and Structural Subtyping","text":"<p>Protocols are a powerful feature introduced in Python\u2019s <code>typing</code> module that enable structural subtyping (also known as \u201cduck typing\u201d in static type checking). Instead of checking if a class explicitly inherits from a base class or interface, protocols check if a class has the required methods and properties.</p>"},{"location":"type-hinting/advanced/protocols/#what-are-protocols","title":"What Are Protocols?","text":"<p>A protocol defines a set of methods and properties that a type must implement to be considered a subtype of that protocol. This allows for more flexible and expressive type checking without requiring explicit inheritance.</p>"},{"location":"type-hinting/advanced/protocols/#defining-a-protocol","title":"Defining a Protocol","text":"<p>You define a protocol by subclassing <code>typing.Protocol</code> and specifying the required methods and properties.</p> <pre><code>from typing import Protocol\n\nclass SupportsClose(Protocol):\n    def close(self) -&gt; None:\n        ...\n</code></pre> <p>Any class that has a <code>close</code> method with the correct signature will be considered a subtype of <code>SupportsClose</code>, even if it does not explicitly inherit from it.</p>"},{"location":"type-hinting/advanced/protocols/#using-protocols-in-functions","title":"Using Protocols in Functions","text":"<p>You can use protocols as type hints to accept any object that matches the protocol\u2019s structure.</p> <pre><code>def close_all(things: list[SupportsClose]) -&gt; None:\n    for thing in things:\n        thing.close()\n</code></pre> <p>This function accepts a list of any objects that have a <code>close</code> method.</p>"},{"location":"type-hinting/advanced/protocols/#example-structural-subtyping","title":"Example: Structural Subtyping","text":"<pre><code>from typing import Protocol\n\nclass SupportsClose(Protocol):\n    def close(self) -&gt; None:\n        ...\n\ndef close_all(things: list[SupportsClose]) -&gt; None:\n    for thing in things:\n        thing.close()\n\nclass File:\n    def close(self) -&gt; None:\n        print(\"File closed\")\n\nclass Socket:\n    def close(self) -&gt; None:\n        print(\"Socket closed\")\n\nclass NotClosable:\n    def disconnect(self) -&gt; None:\n        print(\"Disconnected\")\n\nfiles_and_sockets = [File(), Socket()]\nclose_all(files_and_sockets)  # Works fine\n\nnot_closables = [NotClosable()]\n# close_all(not_closables)  # Type checker will raise an error\n</code></pre>"},{"location":"type-hinting/advanced/protocols/#protocols-with-properties-and-methods","title":"Protocols with Properties and Methods","text":"<p>Protocols can specify properties and methods with precise signatures.</p> <pre><code>from typing import Protocol\n\nclass SupportsLen(Protocol):\n    def __len__(self) -&gt; int:\n        ...\n</code></pre> <p>Any object with a <code>__len__</code> method returning an <code>int</code> is compatible with <code>SupportsLen</code>.</p>"},{"location":"type-hinting/advanced/protocols/#protocols-with-optional-members","title":"Protocols with Optional Members","text":"<p>Protocols can include optional members using <code>@runtime_checkable</code> and <code>typing.runtime_checkable</code>.</p> <pre><code>from typing import Protocol, runtime_checkable\n\n@runtime_checkable\nclass SupportsClose(Protocol):\n    def close(self) -&gt; None:\n        ...\n</code></pre> <p>This enables <code>isinstance</code> checks at runtime:</p> <pre><code>file = File()\nif isinstance(file, SupportsClose):\n    file.close()\n</code></pre>"},{"location":"type-hinting/advanced/protocols/#summary","title":"Summary","text":"Feature Description Protocols Define structural interfaces without explicit inheritance Structural Subtyping Types are compatible if they have required members <code>Protocol</code> class Base class to define protocols <code>@runtime_checkable</code> Allows runtime <code>isinstance</code> checks against protocols Flexible typing Enables duck typing with static type checking <p>Protocols provide a flexible and powerful way to specify interfaces in Python, enabling static type checkers to enforce duck typing principles and improving code robustness and readability.</p>"},{"location":"type-hinting/advanced/type_aliases/","title":"Type Aliases","text":""},{"location":"type-hinting/advanced/type_aliases/#type-aliases-in-python","title":"Type Aliases in Python","text":"<p>Type aliases provide a way to give a new name to an existing type, making complex type hints easier to read and maintain. They are especially useful for simplifying complex type signatures and improving code clarity.</p>"},{"location":"type-hinting/advanced/type_aliases/#defining-type-aliases","title":"Defining Type Aliases","text":"<ol> <li> <p>Type aliases can be defined by simple assignments:</p> <pre><code>Url = str\n\ndef retry(url: Url, retry_count: int) -&gt; None:\n</code></pre> </li> <li> <p>Alternatively, you can use the <code>TypeAlias</code> annotation from the <code>typing</code> module to explicitly declare a type alias:</p> <pre><code>from typing import TypeAlias\n\nUrl: TypeAlias = str\n\ndef retry(url: Url, retry_count: int) -&gt; None:\n</code></pre> </li> <li> <p>Starting with Python 3.12, you can also use the new <code>type</code> statement:</p> <pre><code>type Url = str\n\ndef retry(url: Url, retry_count: int) -&gt; None:\n</code></pre> </li> </ol>"},{"location":"type-hinting/advanced/type_aliases/#naming-conventions","title":"Naming Conventions","text":"<p>Type alias names are typically capitalized to indicate they represent user-defined types, similar to classes.</p>"},{"location":"type-hinting/advanced/type_aliases/#complex-type-aliases","title":"Complex Type Aliases","text":"<p>Type aliases can represent complex types, including generics and bounded type variables:</p> <pre><code>from typing import TypeVar\nfrom collections.abc import Iterable\n\nT = TypeVar('T', bound=float)\n\nVector = Iterable[tuple[T, T]]\n\ndef inproduct(v: Vector[T]) -&gt; T:\n    return sum(x * y for x, y in v)\n\ndef dilate(v: Vector[T], scale: T) -&gt; Vector[T]:\n    return ((x * scale, y * scale) for x, y in v)\n\nvec: Vector[float] = []\n</code></pre> <p>This is equivalent to using the <code>type</code> directly in function signatures:</p> <pre><code>from typing import TypeVar\nfrom collections.abc import Iterable\n\nT = TypeVar('T', bound=float)\n\ndef inproduct(v: Iterable[tuple[T, T]]) -&gt; T:\n    return sum(x * y for x, y in v)\n\ndef dilate(v: Iterable[tuple[T, T]], scale: T) -&gt; Iterable[tuple[T, T]]:\n    return ((x * scale, y * scale) for x, y in v)\n\nvec: Iterable[tuple[float, float]] = []\n</code></pre>"},{"location":"type-hinting/advanced/type_aliases/#explicit-vs-implicit-type-aliases","title":"Explicit vs Implicit Type Aliases","text":"<p>Explicit alias declaration with <code>TypeAlias</code> helps static type checkers distinguish between:</p> <ul> <li>Typed global expressions</li> <li>Untyped global expressions</li> <li>Type aliases</li> </ul> <p>Examples:</p> <pre><code>from typing import TypeAlias\n\nx = 1  # untyped global expression\nx: int = 1  # typed global expression\nx = int  # untyped global expression (not a type alias)\nx: type[int] = int  # typed global expression\nx: TypeAlias = int  # type alias\nx: TypeAlias = \"MyClass\"  # type alias (string literal referencing a forward-declared type)\n</code></pre>"},{"location":"type-hinting/advanced/type_aliases/#using-type-statement-python-312","title":"Using <code>type</code> Statement (Python 3.12+)","text":"<p>The <code>type</code> statement provides a concise way to create type aliases:</p> <pre><code>type Vector = list[float]\n\ndef scale(scalar: float, vector: Vector) -&gt; Vector:\n    return [scalar * num for num in vector]\n\nnew_vector = scale(2.0, [1.0, -4.2, 5.4])\n</code></pre>"},{"location":"type-hinting/advanced/type_aliases/#summary","title":"Summary","text":"<ul> <li>Type aliases simplify complex type annotations.</li> <li>Use <code>TypeAlias</code> to explicitly declare aliases for better type checking.</li> <li>Python 3.12+ supports the <code>type</code> statement for aliasing.</li> <li>Capitalize alias names to follow Python conventions for types.</li> <li>Aliases are interchangeable with their underlying types in static type checking.</li> </ul> <p>This approach improves code readability and maintainability by giving meaningful names to complex types.</p>"},{"location":"type-hinting/basics/collections/","title":"Collections","text":""},{"location":"type-hinting/basics/collections/#type-hints-for-collections-in-python","title":"Type Hints for Collections in Python","text":"<p>Python\u2019s <code>typing</code> module provides special generic types to specify the types of elements inside collections such as lists, dictionaries, sets, and tuples. Using these type hints improves code clarity and enables static type checking.</p>"},{"location":"type-hinting/basics/collections/#common-collection-types","title":"Common Collection Types","text":""},{"location":"type-hinting/basics/collections/#list","title":"List","text":"<p>A list of elements of the same type:</p> <pre><code>from typing import List\n\n\nnumbers: List[int] = [1, 2]\nnames: List[str] = [\"Alice\", \"Bob\", \"Charlie\"]\n</code></pre>"},{"location":"type-hinting/basics/collections/#dictionary","title":"Dictionary","text":"<p>A dictionary with specific key and value types:</p> <pre><code>from typing import Dict\n\nscores: Dict[str, int] = {\"Alice\": 90, \"Bob\": 85}\n</code></pre>"},{"location":"type-hinting/basics/collections/#set","title":"Set","text":"<p>A set of elements of a single type:</p> <pre><code>from typing import Set\n\nunique_ids: Set[int] = {101, 102, 103}\n</code></pre>"},{"location":"type-hinting/basics/collections/#tuple","title":"Tuple","text":"<p>A tuple with fixed length and types for each position:</p> <pre><code>from typing import Tuple\n\npoint: Tuple[int, int] = (10, 20)\nperson: Tuple[str, int, bool] = (\"Alice\", 30, True)\n</code></pre>"},{"location":"type-hinting/basics/collections/#using-iterable-and-sequence","title":"Using <code>Iterable</code> and <code>Sequence</code>","text":"<ul> <li><code>Iterable</code> represents any iterable collection (e.g., lists, sets, tuples).</li> <li><code>Sequence</code> represents ordered collections (like lists and tuples).</li> </ul> <pre><code>from typing import Iterable, Sequence\n\ndef process_items(items: Iterable[str]) -&gt; None:\n    for item in items:\n        print(item)\n\ndef get_first(items: Sequence[int]) -&gt; int:\n    return items\n</code></pre>"},{"location":"type-hinting/basics/collections/#mutable-vs-immutable-collections","title":"Mutable vs Immutable Collections","text":"<ul> <li><code>List</code> and <code>Dict</code> are mutable collections.</li> <li><code>Tuple</code> is immutable.</li> </ul> <p>You can also use <code>Mapping</code> and <code>MutableMapping</code> for dictionaries:</p> <pre><code>from typing import Mapping, MutableMapping\n\ndef read_data(data: Mapping[str, int]) -&gt; None:\n    print(data)\n\ndef update_data(data: MutableMapping[str, int], key: str, value: int) -&gt; None:\n    data[key] = value\n</code></pre>"},{"location":"type-hinting/basics/collections/#nested-collections","title":"Nested Collections","text":"<p>You can nest type hints for collections inside collections:</p> <pre><code>from typing import List, Dict\n\n# A matrix represented as a list of lists of integers\nmatrix: List[List[int]] = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# A dictionary mapping user names (str) to a list of their scores (List[int])\nuser_scores: Dict[str, List[int]] = {\n    \"Alice\": [90, 85, 88],\n    \"Bob\": [75, 80, 79]\n}\n</code></pre>"},{"location":"type-hinting/basics/collections/#summary","title":"Summary","text":"Collection Type Syntax Example Description List <code>List[int]</code> List of integers Dict <code>Dict[str, float]</code> Dict with string keys and float values Set <code>Set[str]</code> Set of strings Tuple <code>Tuple[int, str, bool]</code> Tuple with fixed types Iterable <code>Iterable[str]</code> Any iterable of strings Sequence <code>Sequence[int]</code> Ordered collection of integers <p>Using type hints for collections helps catch bugs early and makes your code easier to understand and maintain.</p>"},{"location":"type-hinting/basics/functions/","title":"Functions","text":""},{"location":"type-hinting/basics/functions/#functions-and-type-hints-in-python","title":"Functions and Type Hints in Python","text":"<p>Type hints for functions specify the expected types of parameters and the return type. This helps improve code clarity, enables static type checking, and enhances IDE support.</p>"},{"location":"type-hinting/basics/functions/#basic-syntax","title":"Basic Syntax","text":"<p>You add type hints to function parameters and the return value using the following syntax:</p> <pre><code>def greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n</code></pre> <ul> <li><code>name: str</code> means the parameter <code>name</code> should be a string.</li> <li><code>-&gt; str</code> indicates the function returns a string.</li> </ul>"},{"location":"type-hinting/basics/functions/#type-hinting-parameters","title":"Type Hinting Parameters","text":"<p>You can specify types for multiple parameters:</p> <pre><code>def add(x: int, y: int) -&gt; int:\n    return x + y\n</code></pre>"},{"location":"type-hinting/basics/functions/#optional-parameters-and-default-values","title":"Optional Parameters and Default Values","text":"<p>Type hints work with default values:</p> <pre><code>def repeat(message: str, times: int = 2) -&gt; str:\n    return message * times\n</code></pre>"},{"location":"type-hinting/basics/functions/#using-optional-for-nullable-parameters","title":"Using <code>Optional</code> for Nullable Parameters","text":"<p>If a parameter can be <code>None</code>, use <code>Optional</code> from the <code>typing</code> module:</p> <pre><code>from typing import Optional\n\ndef welcome(name: Optional[str]) -&gt; str:\n    if name is None:\n        return \"Welcome, guest!\"\n    return f\"Welcome, {name}!\"\n</code></pre>"},{"location":"type-hinting/basics/functions/#multiple-return-types-with-union","title":"Multiple Return Types with <code>Union</code>","text":"<p>If a function can return more than one type, use <code>Union</code>:</p> <pre><code>from typing import Union\n\ndef parse_number(value: str) -&gt; Union[int, float]:\n    try:\n        return int(value)\n    except ValueError:\n        return float(value)\n</code></pre>"},{"location":"type-hinting/basics/functions/#using-any-for-flexible-parameters","title":"Using <code>Any</code> for Flexible Parameters","text":"<p>If you want to accept any type, use <code>Any</code>:</p> <pre><code>from typing import Any\n\ndef process(data: Any) -&gt; None:\n    print(data)\n</code></pre>"},{"location":"type-hinting/basics/functions/#example-full-function-with-type-hints","title":"Example: Full Function with Type Hints","text":"<pre><code>from typing import List\n\ndef average(numbers: List[float]) -&gt; float:\n    return sum(numbers) / len(numbers)\n</code></pre>"},{"location":"type-hinting/basics/functions/#summary","title":"Summary","text":"<ul> <li>Use <code>parameter_name: Type</code> to hint parameter types.</li> <li>Use <code>-&gt; ReturnType</code> to hint the return type.</li> <li>Use <code>Optional[Type]</code> for parameters or returns that can be <code>None</code>.</li> <li>Use <code>Union[Type1, Type2]</code> for multiple possible types.</li> <li>Use <code>Any</code> for unconstrained types.</li> </ul> <p>This guide helps you write clear, type-safe Python functions with type hints.</p>"},{"location":"type-hinting/basics/variables/","title":"Variables","text":""},{"location":"type-hinting/basics/variables/#variables-and-type-hints-in-python","title":"Variables and Type Hints in Python","text":"<p>Type hints allow you to explicitly specify the expected type of a variable in Python. This improves code readability and helps tools like linters and IDEs catch potential bugs.</p>"},{"location":"type-hinting/basics/variables/#basic-syntax","title":"Basic Syntax","text":"<p>To add a type hint to a variable, use a colon <code>:</code> followed by the type after the variable name:</p> <pre><code>age: int = 20\nname: str = \"Alice\"\nis_active: bool = True\n</code></pre> <p>In this example:</p> <ul> <li><code>age</code> is an integer</li> <li><code>name</code> is a string</li> <li><code>is_active</code> is a boolean</li> </ul>"},{"location":"type-hinting/basics/variables/#why-use-type-hints-for-variables","title":"Why Use Type Hints for Variables?","text":"<ul> <li>Documentation: Makes it clear what type a variable is expected to hold.</li> <li>Static Analysis: Tools like <code>mypy</code> can check for type consistency.</li> <li>IDE Support: Better autocompletion and error detection.</li> </ul>"},{"location":"type-hinting/basics/variables/#examples","title":"Examples","text":"<p>Integer variable</p> <pre><code>count: int = 10\n</code></pre> <p>Floating point variable</p> <pre><code>temperature: float = 36.6\n</code></pre> <p>String variable</p> <pre><code>greeting: str = \"Hello, World!\"\n</code></pre> <p>Boolean variable</p> <pre><code>is_valid: bool = False\n</code></pre>"},{"location":"type-hinting/basics/variables/#using-optional-types","title":"Using Optional Types","text":"<p>Sometimes a variable can be of a certain type or <code>None</code>. Use <code>Optional</code> from the <code>typing</code> module:</p> <pre><code>from typing import Optional\n\nuser_id: Optional[int] = None # user_id can be int or None\n</code></pre>"},{"location":"type-hinting/basics/variables/#collections-with-type-hints","title":"Collections with Type Hints","text":"<p>You can also specify types for collections:</p> <pre><code>from typing import List, Dict, Set\n\nnumbers: List[int] = [1, 2]\n\nweights: Dict[str, float] = {\"apple\": 0.5, \"banana\": 0.3}\n\nflags: Set[str] = {\"red\", \"green\", \"blue\"}\n</code></pre> <p>This introduction covers the basics of type hinting for variables in Python, helping you write clearer and more maintainable code.</p>"},{"location":"type-hinting/examples/common_pitfalls/","title":"Common Pitfalls","text":""},{"location":"type-hinting/examples/common_pitfalls/#common-pitfalls-in-fastapi","title":"Common Pitfalls in FastAPI","text":"<p>Building web APIs with FastAPI is efficient and straightforward, but there are several common mistakes that can hinder performance, maintainability, and security. This guide highlights frequent pitfalls to avoid, ensuring your FastAPI applications remain reliable, secure, and robust.</p>"},{"location":"type-hinting/examples/common_pitfalls/#1-not-using-type-hints-properly","title":"1. Not Using Type Hints Properly","text":"<p>Type hints are essential in FastAPI. They help with data validation, generate documentation, and make your code more readable. Ignoring them can lead to errors and make your code harder to maintain.</p> <p>Best Practice:</p> <ul> <li>Always use type hints for function arguments and return values.</li> <li>Use Pydantic models for request and response bodies to leverage automatic validation.</li> </ul>"},{"location":"type-hinting/examples/common_pitfalls/#2-ignoring-dependency-injection","title":"2. Ignoring Dependency Injection","text":"<p>Dependency injection (DI) helps manage dependencies such as database connections or configuration settings efficiently. Failing to use DI can result in messy, hard-to-test code.</p> <p>Best Practice:</p> <ul> <li>Use FastAPI\u2019s dependency injection system to keep your code modular and testable.</li> <li>Define reusable dependencies with <code>Depends</code>.</li> </ul>"},{"location":"type-hinting/examples/common_pitfalls/#3-neglecting-validation","title":"3. Neglecting Validation","text":"<p>FastAPI automatically validates data based on the type hints you provide. Some developers forget to specify these hints or rely on manual validation, leading to unhandled errors.</p> <p>Best Practice:</p> <ul> <li>Let FastAPI handle validation using type hints and Pydantic models.</li> <li>Avoid manual validation unless absolutely necessary.</li> </ul>"},{"location":"type-hinting/examples/common_pitfalls/#4-poor-error-handling","title":"4. Poor Error Handling","text":"<p>Proper error handling is crucial for a good user experience and application stability. Vague or missing error responses can confuse users and make debugging difficult.</p> <p>Best Practice:</p> <ul> <li>Use FastAPI\u2019s exception handlers to manage errors gracefully.</li> <li>Raise <code>HTTPException</code> with appropriate status codes and messages.</li> <li>Provide clear and meaningful error responses.</li> </ul>"},{"location":"type-hinting/examples/common_pitfalls/#5-overlooking-security-practices","title":"5. Overlooking Security Practices","text":"<p>Security mistakes can expose sensitive information or leave your API vulnerable.</p> <p>Common Issues:</p> <ul> <li>Exposing sensitive data in error messages.</li> <li>Using insecure authentication methods.</li> <li>Not validating input data properly.</li> </ul> <p>Best Practice:</p> <ul> <li>Use HTTPS for secure communication.</li> <li>Implement OAuth2 or other secure authentication mechanisms.</li> <li>Validate all input data rigorously.</li> </ul>"},{"location":"type-hinting/examples/common_pitfalls/#6-not-optimizing-performance","title":"6. Not Optimizing Performance","text":"<p>FastAPI is designed for high performance, but certain practices can degrade it.</p> <p>Common Pitfalls:</p> <ul> <li>Blocking I/O operations in async endpoints.</li> <li>Inefficient database queries.</li> <li>Excessive data processing in request handlers.</li> </ul> <p>Best Practice:</p> <ul> <li>Use asynchronous programming for I/O-bound tasks.</li> <li>Optimize database interactions with indexes and efficient queries.</li> <li>Profile your application to identify bottlenecks.</li> </ul>"},{"location":"type-hinting/examples/common_pitfalls/#7-ignoring-scalability","title":"7. Ignoring Scalability","text":"<p>Building APIs without considering scalability can lead to maintenance headaches as your app grows.</p> <p>Best Practice:</p> <ul> <li>Structure your codebase modularly.</li> <li>Use middleware to handle cross-cutting concerns.</li> <li>Plan for horizontal scaling and statelessness.</li> </ul>"},{"location":"type-hinting/examples/common_pitfalls/#8-skipping-documentation-and-testing","title":"8. Skipping Documentation and Testing","text":"<p>Lack of proper documentation and testing reduces code quality and developer productivity.</p> <p>Best Practice:</p> <ul> <li>Leverage FastAPI\u2019s automatic API docs (<code>/docs</code> and <code>/redoc</code>).</li> <li>Write unit and integration tests for your endpoints.</li> <li>Document complex business logic clearly.</li> </ul>"},{"location":"type-hinting/examples/common_pitfalls/#summary-table","title":"Summary Table","text":"Pitfall Impact Recommended Practice Missing Type Hints Validation errors, poor docs Use type hints and Pydantic models Ignoring Dependency Injection Messy, untestable code Use FastAPI DI system Neglecting Validation Data integrity issues Rely on FastAPI validation Poor Error Handling Bad UX, debugging difficulty Use exception handlers and clear errors Overlooking Security Vulnerabilities Follow security best practices Not Optimizing Performance Slow response times Use async, optimize DB queries Ignoring Scalability Maintenance challenges Modular design, middleware, scaling Skipping Docs and Testing Reduced maintainability Use built-in docs and write tests <p>By being aware of these common pitfalls and following best practices, you can build more reliable, secure, and efficient APIs with FastAPI.</p> <p>References:</p> <ul> <li>FastAPI Best Practices</li> <li>Handling Errors in FastAPI</li> <li>7 Mistakes to Avoid When Using FastAPI</li> <li>FastAPI Error Handling Patterns</li> </ul>"},{"location":"type-hinting/examples/real_projects/","title":"Using Type Hints in Real Projects","text":""},{"location":"type-hinting/examples/real_projects/#using-type-hints-in-real-projects","title":"Using Type Hints in Real Projects","text":"<p>Type hints in Python are a powerful tool to improve code readability, maintainability, and tooling support. They serve as documentation for developers and enable static type checkers to catch bugs early. In real-world projects, type hints are widely adopted in libraries, frameworks, and applications.</p>"},{"location":"type-hinting/examples/real_projects/#benefits-of-using-type-hints","title":"Benefits of Using Type Hints","text":"<ul> <li>Improved code clarity: Types clarify what kind of data is expected.</li> <li>Better tooling: IDEs can provide autocompletion, refactoring, and error detection.</li> <li>Early bug detection: Static type checkers like <code>mypy</code> can catch type mismatches before runtime.</li> <li>Enhanced collaboration: Teams understand interfaces and data flow better.</li> </ul>"},{"location":"type-hinting/examples/real_projects/#basic-type-hint-examples","title":"Basic Type Hint Examples","text":"<pre><code>age: int = 20\nname: str = \"Alice\"\nis_active: bool = True\n\ndef greet(user_name: str) -&gt; str:\n    return \"Hello, \" + user_name\n</code></pre>"},{"location":"type-hinting/examples/real_projects/#complex-types","title":"Complex Types","text":"<p>Python\u2019s <code>typing</code> module allows you to specify complex types such as lists, dictionaries, tuples, sets, and optionals.</p> <pre><code>from typing import Optional, List, Dict, Tuple, Set\n\nnumbers: List[int] = [1, 2, 3, 4, 5]\n\nweights: Dict[str, float] = {\"apple\": 0.5, \"banana\": 0.75}\nstudent: Tuple[int, str] = (123, \"John Doe\")\nflags: Set[str] = {\"apple\", \"banana\", \"cherry\"}\n\ndef find_student(student_id: int) -&gt; Optional[Dict[str, str]]:\n    # Returns student data or None if not found\n    # Example implementation (stub)\n    students = {\n        123: {\"name\": \"John Doe\", \"grade\": \"A\"},\n        456: {\"name\": \"Jane Smith\", \"grade\": \"B\"},\n    }\n    return students.get(student_id)\n</code></pre>"},{"location":"type-hinting/examples/real_projects/#type-hints-in-classes-and-methods","title":"Type Hints in Classes and Methods","text":"<pre><code>from typing import List\n\nclass Student:\n    def __init__(self, name: str, grades: List[int]) -&gt; None:\n        self.name = name\n        self.grades = grades\n\n    def average_grade(self) -&gt; float:\n        return sum(self.grades) / len(self.grades)\n\nstudent = Student(\"John\", [85, 90, 88])\nprint(student.average_grade())  # Output: 87.66666666666667\n</code></pre>"},{"location":"type-hinting/examples/real_projects/#using-type-variables-and-generics","title":"Using Type Variables and Generics","text":"<pre><code>from typing import TypeVar, List\n\nT = TypeVar('T')\n\ndef first_element(items: List[T]) -&gt; T:\n    return items[0]\n</code></pre>"},{"location":"type-hinting/examples/real_projects/#real-world-examples","title":"Real-World Examples","text":""},{"location":"type-hinting/examples/real_projects/#pydantic-models-for-data-validation","title":"Pydantic Models for Data Validation","text":"<p>Pydantic uses type hints to validate and parse data at runtime.</p> <pre><code>from pydantic import BaseModel\nfrom datetime import datetime\n\nclass Delivery(BaseModel):\n    timestamp: datetime\n    dimensions: tuple[int, int]\n\ndelivery = Delivery(timestamp=\"2024-05-17T10:00:00Z\", dimensions=(10, 20))\nprint(delivery)\n</code></pre>"},{"location":"type-hinting/examples/real_projects/#fastapi-for-api-endpoints","title":"FastAPI for API Endpoints","text":"<p>FastAPI uses type hints to generate API schemas and validate requests.</p> <pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n    return item\n</code></pre>"},{"location":"type-hinting/examples/real_projects/#tips-for-using-type-hints-in-projects","title":"Tips for Using Type Hints in Projects","text":"<ul> <li>Start by adding type hints to public APIs and critical modules.</li> <li>Use tools like <code>mypy</code> to enforce type correctness.</li> <li>Combine type hints with docstrings for comprehensive documentation.</li> <li>Gradually add types to legacy codebases to improve maintainability.</li> </ul>"},{"location":"type-hinting/examples/real_projects/#summary","title":"Summary","text":"<p>Type hints are a practical addition to Python that help you write safer, clearer, and more maintainable code. They are increasingly adopted in real projects, from small scripts to large frameworks, improving developer experience and code quality.</p> <p>If you want to explore more, consider checking out:</p> <ul> <li>Python <code>typing</code> module documentation</li> <li>Mypy static type checker</li> <li>Real-world projects like FastAPI and Pydantic</li> </ul>"},{"location":"type-hinting/reference/pep484/","title":"PEP 484 Overview","text":""},{"location":"type-hinting/reference/pep484/#pep-484-overview","title":"PEP 484 Overview","text":"<p>PEP 484 - Type Hints - introduced a standard way to add type hints to Python code. It enables static type checking, improved code readability, and better tooling support without affecting runtime behavior.</p>"},{"location":"type-hinting/reference/pep484/#motivation","title":"Motivation","text":"<p>Python is a dynamically typed language, which means types are checked at runtime. While this provides flexibility, it can lead to bugs that are only caught during execution. PEP 484 introduces optional type hints to help catch errors earlier using static analysis tools like <code>mypy</code>.</p>"},{"location":"type-hinting/reference/pep484/#syntax-of-type-hints","title":"Syntax of Type Hints","text":"<p>Type hints are annotations that specify the expected type of variables, function parameters, and return values.</p> <pre><code>def greeting(name: str) -&gt; str:\n    return 'Hello, ' + name\n</code></pre> <ul> <li><code>name: str</code> indicates <code>name</code> should be a string.</li> <li><code>-&gt; str</code> indicates the function returns a string.</li> </ul>"},{"location":"type-hinting/reference/pep484/#variable-annotations","title":"Variable Annotations","text":"<p>Variables can also be annotated with types:</p> <pre><code>age: int = 25\nnames: list[str] = ['Alice', 'Bob']\n</code></pre>"},{"location":"type-hinting/reference/pep484/#type-hints-for-functions","title":"Type Hints for Functions","text":"<p>Function parameters and return types can be annotated:</p> <pre><code>from typing import Optional\n\ndef square(number: int) -&gt; int:\n    return number * number\n\ndef greet(name: Optional[str] = None) -&gt; str:\n    if name:\n        return 'Hello, ' + name\n    else:\n        return 'Hello, stranger'\n</code></pre> <ul> <li><code>Optional[str]</code> means the argument can be a string or <code>None</code>.</li> </ul>"},{"location":"type-hinting/reference/pep484/#complex-types-with-typing-module","title":"Complex Types with <code>typing</code> Module","text":"<p>PEP 484 introduced the <code>typing</code> module to express complex types:</p> <pre><code>from typing import List, Dict, Tuple\n\nnames: List[str] = ['Alice', 'Bob']\nscores: Dict[str, int] = {'Alice': 90, 'Bob': 85}\ncoordinates: Tuple[int, int] = (10, 20)\n</code></pre>"},{"location":"type-hinting/reference/pep484/#type-aliases","title":"Type Aliases","text":"<p>You can create aliases for complex types to improve readability:</p> <pre><code>from typing import List, Tuple\n\nVector = List[Tuple[int, int]]\n\ndef scale(vector: Vector, scalar: int) -&gt; Vector:\n    return [(x * scalar, y * scalar) for x, y in vector]\n</code></pre>"},{"location":"type-hinting/reference/pep484/#type-variables-and-generics","title":"Type Variables and Generics","text":"<p>PEP 484 supports generic programming with type variables:</p> <pre><code>from typing import TypeVar, List\n\nT = TypeVar('T')\n\ndef first_element(items: List[T]) -&gt; T:\n    return items[0]\n</code></pre>"},{"location":"type-hinting/reference/pep484/#limitations","title":"Limitations","text":"<ul> <li>Type hints are optional and do not affect runtime behavior.</li> <li>Python does not enforce type hints; they are for static analysis tools.</li> <li>Some dynamic features of Python are hard to type precisely.</li> </ul>"},{"location":"type-hinting/reference/pep484/#impact-and-adoption","title":"Impact and Adoption","text":"<p>Since PEP 484, type hints have been widely adopted in the Python community. Popular tools like <code>mypy</code>, <code>pyright</code>, and IDEs leverage type hints to provide better developer experience.</p>"},{"location":"type-hinting/reference/pep484/#summary","title":"Summary","text":"Feature Description Optional Typing Type hints are optional and do not affect runtime Static Analysis Tools like <code>mypy</code> use hints to catch bugs early <code>typing</code> Module Provides complex type constructs and generics Improved Readability Makes code easier to understand and maintain Generic Programming Supports writing reusable, type-safe code"},{"location":"type-hinting/reference/pep484/#references","title":"References","text":"<ul> <li>PEP 484 \u2013 Type Hints</li> <li>Typing - Official Python Documentation</li> <li>Mypy - Optional Static Typing for Python</li> </ul> <p>This document provides a concise overview of PEP 484 and its significance in Python's type hinting ecosystem.</p>"},{"location":"type-hinting/reference/typing_module/","title":"Typing Module","text":""},{"location":"type-hinting/reference/typing_module/#typing-module-overview","title":"Typing Module Overview","text":"<p>The <code>typing</code> module in Python provides a rich set of tools to support type hints and static type checking. Introduced in PEP 484, it enables developers to specify complex types, generics, and protocols, improving code readability, maintainability, and tooling support.</p>"},{"location":"type-hinting/reference/typing_module/#commonly-used-types","title":"Commonly Used Types","text":""},{"location":"type-hinting/reference/typing_module/#basic-collection-types","title":"Basic Collection Types","text":"<pre><code>from typing import List, Dict, Tuple, Set\n\nnames: List[str] = ['Alice', 'Bob', 'Charlie']\nscores: Dict[str, int] = {'Alice': 90, 'Bob': 85}\ncoordinates: Tuple[int, int] = (10, 20)\nunique_ids: Set[int] = {1, 2, 3}\n</code></pre> <ul> <li><code>List[T]</code>: A list of elements of type <code>T</code>.</li> <li><code>Dict[K, V]</code>: A dictionary with keys of type <code>K</code> and values of type <code>V</code>.</li> <li><code>Tuple[T1, T2, ...]</code>: A fixed-length tuple with specified types.</li> <li><code>Set[T]</code>: A set of elements of type <code>T</code>.</li> </ul> <p>This syntax is valid for <code>Python 3.5</code> and later. For <code>Python 3.9+</code>, you can also use built-in <code>generic types</code> directly, like:</p> <pre><code>names: list[str] = ['Alice', 'Bob', 'Charlie']\nscores: dict[str, int] = {'Alice': 90, 'Bob': 85}\ncoordinates: tuple[int, int] = (10, 20)\nunique_ids: set[int] = {1, 2, 3}\n</code></pre>"},{"location":"type-hinting/reference/typing_module/#optional-and-union-types","title":"Optional and Union Types","text":""},{"location":"type-hinting/reference/typing_module/#optional","title":"Optional","text":"<p>Represents a type that could also be <code>None</code>.</p> <pre><code>from typing import Optional\n\ndef find_user(user_id: int) -&gt; Optional[str]:\n    # Returns a username or None if not found\n    users = {\n        1: \"Alice\",\n        2: \"Bob\",\n        3: \"Charlie\"\n    }\n    return users.get(user_id)\n</code></pre> <p>Equivalent to <code>Union[T, None]</code>.</p>"},{"location":"type-hinting/reference/typing_module/#union","title":"Union","text":"<p>Represents a value that could be one of several types.</p> <pre><code>from typing import Union\n\ndef process(value: Union[int, str]) -&gt; None:\n    if isinstance(value, int):\n        print(f\"Processing integer {value}\")\n    else:\n        print(f\"Processing string {value}\")\n</code></pre>"},{"location":"type-hinting/reference/typing_module/#any-and-noreturn","title":"Any and NoReturn","text":"<ul> <li> <p><code>Any</code>: Disables type checking for a variable.</p> <pre><code>from typing import Any\n\ndef log(data: Any) -&gt; None:\n    print(data)\n</code></pre> </li> <li> <p><code>NoReturn</code>: Indicates a function that never returns (e.g., always raises an exception).</p> <pre><code>from typing import NoReturn\n\ndef fatal_error() -&gt; NoReturn:\n    raise RuntimeError(\"Fatal error occurred\")\n</code></pre> </li> </ul>"},{"location":"type-hinting/reference/typing_module/#type-aliases","title":"Type Aliases","text":"<p>You can create aliases for complex types to improve readability.</p> <pre><code>from typing import List, Tuple\n\nVector = List[Tuple[int, int]]\n\ndef scale(vector: Vector, scalar: int) -&gt; Vector:\n    return [(x * scalar, y * scalar) for x, y in vector]\n</code></pre>"},{"location":"type-hinting/reference/typing_module/#type-variables-and-generics","title":"Type Variables and Generics","text":"<p>Support for generic programming using <code>TypeVar</code>.</p> <pre><code>from typing import TypeVar, List\n\nT = TypeVar('T')\n\ndef first_element(items: List[T]) -&gt; T:\n    return items[0]\n</code></pre>"},{"location":"type-hinting/reference/typing_module/#callable-types","title":"Callable Types","text":"<p>Used to specify function signatures.</p> <pre><code>from typing import Callable\n\ndef apply_func(func: Callable[[int, int], int], x: int, y: int) -&gt; int:\n    return func(x, y)\n</code></pre> <ul> <li>The example above expects a function <code>func</code> that takes two integers and returns an integer.</li> </ul>"},{"location":"type-hinting/reference/typing_module/#protocols-structural-subtyping","title":"Protocols (Structural Subtyping)","text":"<p>Protocols define interfaces that types can implement without explicit inheritance.</p> <pre><code>from typing import Protocol\n\nclass SupportsClose(Protocol):\n    def close(self) -&gt; None:\n        ...\n</code></pre> <p>Any object with a <code>close</code> method matching the signature is considered a subtype.</p>"},{"location":"type-hinting/reference/typing_module/#literal-types","title":"Literal Types","text":"<p>Specify that a variable or parameter must be one of a set of literal values.</p> <pre><code>from typing import Literal\n\ndef draw_shape(shape: Literal['circle', 'square', 'triangle']) -&gt; None:\n    print(f\"Drawing a {shape}\")\n</code></pre>"},{"location":"type-hinting/reference/typing_module/#newtype","title":"NewType","text":"<p>Create distinct types for stronger type checking without runtime overhead.</p> <pre><code>from typing import NewType\n\nUserId = NewType('UserId', int)\n\ndef get_user_name(user_id: UserId) -&gt; str:\n    # Example implementation (replace with actual logic)\n    user_database = {\n        UserId(1): \"Alice\",\n        UserId(2): \"Bob\",\n        UserId(3): \"Charlie\"\n    }\n    return user_database.get(user_id, \"Unknown User\")\n</code></pre>"},{"location":"type-hinting/reference/typing_module/#typeddict","title":"TypedDict","text":"<p>Define dictionary types with specific keys and value types.</p> <pre><code>from typing import TypedDict\n\nclass Movie(TypedDict):\n    title: str\n    year: int\n\nmovie: Movie = {'title': 'Inception', 'year': 2010}\n</code></pre>"},{"location":"type-hinting/reference/typing_module/#final-and-classvar","title":"Final and ClassVar","text":"<ul> <li> <p><code>Final</code>: Indicates a variable or attribute should not be reassigned.</p> <pre><code>from typing import Final\n\nMAX_SIZE: Final = 100\n</code></pre> </li> <li> <p><code>ClassVar</code>: Indicates a variable is a class variable, not an instance variable.</p> <pre><code>from typing import ClassVar\n\nclass MyClass:\n    version: ClassVar[int] = 1\n</code></pre> </li> </ul>"},{"location":"type-hinting/reference/typing_module/#summary-table","title":"Summary Table","text":"Typing Feature Description <code>List</code>, <code>Dict</code>, etc. Generic collection types <code>Optional</code> Type or <code>None</code> <code>Union</code> One of multiple types <code>Any</code> Disable type checking <code>NoReturn</code> Functions that never return <code>TypeVar</code> Generic type variables <code>Callable</code> Function signatures <code>Protocol</code> Structural subtyping <code>Literal</code> Specific literal values <code>NewType</code> Distinct types for stronger checking <code>TypedDict</code> Typed dictionaries <code>Final</code> Constants <code>ClassVar</code> Class variables"},{"location":"type-hinting/reference/typing_module/#references","title":"References","text":"<ul> <li>Python <code>typing</code> module documentation</li> <li>PEP 484 \u2013 Type Hints</li> <li>PEP 544 \u2013 Protocols: Structural subtyping</li> <li>PEP 586 \u2013 Literal Types</li> <li>PEP 589 \u2013 TypedDict</li> <li>PEP 591 \u2013 Final qualifier</li> </ul> <p>This document provides a comprehensive overview of the <code>typing</code> module's features and usage to help you write clearer, safer, and more maintainable Python code.</p>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2024/","title":"2024","text":""}]}